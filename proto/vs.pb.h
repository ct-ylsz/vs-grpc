// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[43]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vs_2eproto;
namespace vs {
class DbPingReq;
struct DbPingReqDefaultTypeInternal;
extern DbPingReqDefaultTypeInternal _DbPingReq_default_instance_;
class DbPingResp;
struct DbPingRespDefaultTypeInternal;
extern DbPingRespDefaultTypeInternal _DbPingResp_default_instance_;
class ErrInfo;
struct ErrInfoDefaultTypeInternal;
extern ErrInfoDefaultTypeInternal _ErrInfo_default_instance_;
class GetRTDataByBatchReq;
struct GetRTDataByBatchReqDefaultTypeInternal;
extern GetRTDataByBatchReqDefaultTypeInternal _GetRTDataByBatchReq_default_instance_;
class GetRTDataByBatchResp;
struct GetRTDataByBatchRespDefaultTypeInternal;
extern GetRTDataByBatchRespDefaultTypeInternal _GetRTDataByBatchResp_default_instance_;
class HeadReq;
struct HeadReqDefaultTypeInternal;
extern HeadReqDefaultTypeInternal _HeadReq_default_instance_;
class InsertData;
struct InsertDataDefaultTypeInternal;
extern InsertDataDefaultTypeInternal _InsertData_default_instance_;
class KVInfo;
struct KVInfoDefaultTypeInternal;
extern KVInfoDefaultTypeInternal _KVInfo_default_instance_;
class KVInfo_KvsEntry_DoNotUse;
struct KVInfo_KvsEntry_DoNotUseDefaultTypeInternal;
extern KVInfo_KvsEntry_DoNotUseDefaultTypeInternal _KVInfo_KvsEntry_DoNotUse_default_instance_;
class ReleaseConnectReq;
struct ReleaseConnectReqDefaultTypeInternal;
extern ReleaseConnectReqDefaultTypeInternal _ReleaseConnectReq_default_instance_;
class ReleaseConnectResp;
struct ReleaseConnectRespDefaultTypeInternal;
extern ReleaseConnectRespDefaultTypeInternal _ReleaseConnectResp_default_instance_;
class ServiceStopReq;
struct ServiceStopReqDefaultTypeInternal;
extern ServiceStopReqDefaultTypeInternal _ServiceStopReq_default_instance_;
class ServiceStopResp;
struct ServiceStopRespDefaultTypeInternal;
extern ServiceStopRespDefaultTypeInternal _ServiceStopResp_default_instance_;
class TagAppendRTTagDataByBatchReq;
struct TagAppendRTTagDataByBatchReqDefaultTypeInternal;
extern TagAppendRTTagDataByBatchReqDefaultTypeInternal _TagAppendRTTagDataByBatchReq_default_instance_;
class TagAppendRTTagDataByBatchResp;
struct TagAppendRTTagDataByBatchRespDefaultTypeInternal;
extern TagAppendRTTagDataByBatchRespDefaultTypeInternal _TagAppendRTTagDataByBatchResp_default_instance_;
class TagCountByRangeGetReq;
struct TagCountByRangeGetReqDefaultTypeInternal;
extern TagCountByRangeGetReqDefaultTypeInternal _TagCountByRangeGetReq_default_instance_;
class TagCountByRangeGetResp;
struct TagCountByRangeGetRespDefaultTypeInternal;
extern TagCountByRangeGetRespDefaultTypeInternal _TagCountByRangeGetResp_default_instance_;
class TagDescGetReq;
struct TagDescGetReqDefaultTypeInternal;
extern TagDescGetReqDefaultTypeInternal _TagDescGetReq_default_instance_;
class TagDescGetResp;
struct TagDescGetRespDefaultTypeInternal;
extern TagDescGetRespDefaultTypeInternal _TagDescGetResp_default_instance_;
class TagDescGetResp_DescEntry_DoNotUse;
struct TagDescGetResp_DescEntry_DoNotUseDefaultTypeInternal;
extern TagDescGetResp_DescEntry_DoNotUseDefaultTypeInternal _TagDescGetResp_DescEntry_DoNotUse_default_instance_;
class TagFeatureGetReq;
struct TagFeatureGetReqDefaultTypeInternal;
extern TagFeatureGetReqDefaultTypeInternal _TagFeatureGetReq_default_instance_;
class TagFeatureGetResp;
struct TagFeatureGetRespDefaultTypeInternal;
extern TagFeatureGetRespDefaultTypeInternal _TagFeatureGetResp_default_instance_;
class TagFeatureGetResp_FeatsEntry_DoNotUse;
struct TagFeatureGetResp_FeatsEntry_DoNotUseDefaultTypeInternal;
extern TagFeatureGetResp_FeatsEntry_DoNotUseDefaultTypeInternal _TagFeatureGetResp_FeatsEntry_DoNotUse_default_instance_;
class TagFractureSectionGetReq;
struct TagFractureSectionGetReqDefaultTypeInternal;
extern TagFractureSectionGetReqDefaultTypeInternal _TagFractureSectionGetReq_default_instance_;
class TagFractureSectionGetReq_ExtendsEntry_DoNotUse;
struct TagFractureSectionGetReq_ExtendsEntry_DoNotUseDefaultTypeInternal;
extern TagFractureSectionGetReq_ExtendsEntry_DoNotUseDefaultTypeInternal _TagFractureSectionGetReq_ExtendsEntry_DoNotUse_default_instance_;
class TagFractureSectionGetResp;
struct TagFractureSectionGetRespDefaultTypeInternal;
extern TagFractureSectionGetRespDefaultTypeInternal _TagFractureSectionGetResp_default_instance_;
class TagListGetReq;
struct TagListGetReqDefaultTypeInternal;
extern TagListGetReqDefaultTypeInternal _TagListGetReq_default_instance_;
class TagListGetResp;
struct TagListGetRespDefaultTypeInternal;
extern TagListGetRespDefaultTypeInternal _TagListGetResp_default_instance_;
class TagListGetResp_TagInfoMap;
struct TagListGetResp_TagInfoMapDefaultTypeInternal;
extern TagListGetResp_TagInfoMapDefaultTypeInternal _TagListGetResp_TagInfoMap_default_instance_;
class TagListGetResp_TagInfoMap_InfosEntry_DoNotUse;
struct TagListGetResp_TagInfoMap_InfosEntry_DoNotUseDefaultTypeInternal;
extern TagListGetResp_TagInfoMap_InfosEntry_DoNotUseDefaultTypeInternal _TagListGetResp_TagInfoMap_InfosEntry_DoNotUse_default_instance_;
class TagSnapshotValueReq;
struct TagSnapshotValueReqDefaultTypeInternal;
extern TagSnapshotValueReqDefaultTypeInternal _TagSnapshotValueReq_default_instance_;
class TagSnapshotValueResp;
struct TagSnapshotValueRespDefaultTypeInternal;
extern TagSnapshotValueRespDefaultTypeInternal _TagSnapshotValueResp_default_instance_;
class TagTimeSectionReq;
struct TagTimeSectionReqDefaultTypeInternal;
extern TagTimeSectionReqDefaultTypeInternal _TagTimeSectionReq_default_instance_;
class TagTimeSectionResp;
struct TagTimeSectionRespDefaultTypeInternal;
extern TagTimeSectionRespDefaultTypeInternal _TagTimeSectionResp_default_instance_;
class TagValuesByCountGetReq;
struct TagValuesByCountGetReqDefaultTypeInternal;
extern TagValuesByCountGetReqDefaultTypeInternal _TagValuesByCountGetReq_default_instance_;
class TagValuesByCountGetReq_MetaEntry_DoNotUse;
struct TagValuesByCountGetReq_MetaEntry_DoNotUseDefaultTypeInternal;
extern TagValuesByCountGetReq_MetaEntry_DoNotUseDefaultTypeInternal _TagValuesByCountGetReq_MetaEntry_DoNotUse_default_instance_;
class TagValuesByCountGetResp;
struct TagValuesByCountGetRespDefaultTypeInternal;
extern TagValuesByCountGetRespDefaultTypeInternal _TagValuesByCountGetResp_default_instance_;
class TagValuesGetReq;
struct TagValuesGetReqDefaultTypeInternal;
extern TagValuesGetReqDefaultTypeInternal _TagValuesGetReq_default_instance_;
class TagValuesGetReq_ExtendEntry_DoNotUse;
struct TagValuesGetReq_ExtendEntry_DoNotUseDefaultTypeInternal;
extern TagValuesGetReq_ExtendEntry_DoNotUseDefaultTypeInternal _TagValuesGetReq_ExtendEntry_DoNotUse_default_instance_;
class TagValuesGetResp;
struct TagValuesGetRespDefaultTypeInternal;
extern TagValuesGetRespDefaultTypeInternal _TagValuesGetResp_default_instance_;
class VsValue;
struct VsValueDefaultTypeInternal;
extern VsValueDefaultTypeInternal _VsValue_default_instance_;
class VsValueMap;
struct VsValueMapDefaultTypeInternal;
extern VsValueMapDefaultTypeInternal _VsValueMap_default_instance_;
class VsValueMap_ValueMapEntry_DoNotUse;
struct VsValueMap_ValueMapEntry_DoNotUseDefaultTypeInternal;
extern VsValueMap_ValueMapEntry_DoNotUseDefaultTypeInternal _VsValueMap_ValueMapEntry_DoNotUse_default_instance_;
}  // namespace vs
PROTOBUF_NAMESPACE_OPEN
template<> ::vs::DbPingReq* Arena::CreateMaybeMessage<::vs::DbPingReq>(Arena*);
template<> ::vs::DbPingResp* Arena::CreateMaybeMessage<::vs::DbPingResp>(Arena*);
template<> ::vs::ErrInfo* Arena::CreateMaybeMessage<::vs::ErrInfo>(Arena*);
template<> ::vs::GetRTDataByBatchReq* Arena::CreateMaybeMessage<::vs::GetRTDataByBatchReq>(Arena*);
template<> ::vs::GetRTDataByBatchResp* Arena::CreateMaybeMessage<::vs::GetRTDataByBatchResp>(Arena*);
template<> ::vs::HeadReq* Arena::CreateMaybeMessage<::vs::HeadReq>(Arena*);
template<> ::vs::InsertData* Arena::CreateMaybeMessage<::vs::InsertData>(Arena*);
template<> ::vs::KVInfo* Arena::CreateMaybeMessage<::vs::KVInfo>(Arena*);
template<> ::vs::KVInfo_KvsEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::KVInfo_KvsEntry_DoNotUse>(Arena*);
template<> ::vs::ReleaseConnectReq* Arena::CreateMaybeMessage<::vs::ReleaseConnectReq>(Arena*);
template<> ::vs::ReleaseConnectResp* Arena::CreateMaybeMessage<::vs::ReleaseConnectResp>(Arena*);
template<> ::vs::ServiceStopReq* Arena::CreateMaybeMessage<::vs::ServiceStopReq>(Arena*);
template<> ::vs::ServiceStopResp* Arena::CreateMaybeMessage<::vs::ServiceStopResp>(Arena*);
template<> ::vs::TagAppendRTTagDataByBatchReq* Arena::CreateMaybeMessage<::vs::TagAppendRTTagDataByBatchReq>(Arena*);
template<> ::vs::TagAppendRTTagDataByBatchResp* Arena::CreateMaybeMessage<::vs::TagAppendRTTagDataByBatchResp>(Arena*);
template<> ::vs::TagCountByRangeGetReq* Arena::CreateMaybeMessage<::vs::TagCountByRangeGetReq>(Arena*);
template<> ::vs::TagCountByRangeGetResp* Arena::CreateMaybeMessage<::vs::TagCountByRangeGetResp>(Arena*);
template<> ::vs::TagDescGetReq* Arena::CreateMaybeMessage<::vs::TagDescGetReq>(Arena*);
template<> ::vs::TagDescGetResp* Arena::CreateMaybeMessage<::vs::TagDescGetResp>(Arena*);
template<> ::vs::TagDescGetResp_DescEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagDescGetResp_DescEntry_DoNotUse>(Arena*);
template<> ::vs::TagFeatureGetReq* Arena::CreateMaybeMessage<::vs::TagFeatureGetReq>(Arena*);
template<> ::vs::TagFeatureGetResp* Arena::CreateMaybeMessage<::vs::TagFeatureGetResp>(Arena*);
template<> ::vs::TagFeatureGetResp_FeatsEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagFeatureGetResp_FeatsEntry_DoNotUse>(Arena*);
template<> ::vs::TagFractureSectionGetReq* Arena::CreateMaybeMessage<::vs::TagFractureSectionGetReq>(Arena*);
template<> ::vs::TagFractureSectionGetReq_ExtendsEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagFractureSectionGetReq_ExtendsEntry_DoNotUse>(Arena*);
template<> ::vs::TagFractureSectionGetResp* Arena::CreateMaybeMessage<::vs::TagFractureSectionGetResp>(Arena*);
template<> ::vs::TagListGetReq* Arena::CreateMaybeMessage<::vs::TagListGetReq>(Arena*);
template<> ::vs::TagListGetResp* Arena::CreateMaybeMessage<::vs::TagListGetResp>(Arena*);
template<> ::vs::TagListGetResp_TagInfoMap* Arena::CreateMaybeMessage<::vs::TagListGetResp_TagInfoMap>(Arena*);
template<> ::vs::TagListGetResp_TagInfoMap_InfosEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagListGetResp_TagInfoMap_InfosEntry_DoNotUse>(Arena*);
template<> ::vs::TagSnapshotValueReq* Arena::CreateMaybeMessage<::vs::TagSnapshotValueReq>(Arena*);
template<> ::vs::TagSnapshotValueResp* Arena::CreateMaybeMessage<::vs::TagSnapshotValueResp>(Arena*);
template<> ::vs::TagTimeSectionReq* Arena::CreateMaybeMessage<::vs::TagTimeSectionReq>(Arena*);
template<> ::vs::TagTimeSectionResp* Arena::CreateMaybeMessage<::vs::TagTimeSectionResp>(Arena*);
template<> ::vs::TagValuesByCountGetReq* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetReq>(Arena*);
template<> ::vs::TagValuesByCountGetReq_MetaEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetReq_MetaEntry_DoNotUse>(Arena*);
template<> ::vs::TagValuesByCountGetResp* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetResp>(Arena*);
template<> ::vs::TagValuesGetReq* Arena::CreateMaybeMessage<::vs::TagValuesGetReq>(Arena*);
template<> ::vs::TagValuesGetReq_ExtendEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagValuesGetReq_ExtendEntry_DoNotUse>(Arena*);
template<> ::vs::TagValuesGetResp* Arena::CreateMaybeMessage<::vs::TagValuesGetResp>(Arena*);
template<> ::vs::VsValue* Arena::CreateMaybeMessage<::vs::VsValue>(Arena*);
template<> ::vs::VsValueMap* Arena::CreateMaybeMessage<::vs::VsValueMap>(Arena*);
template<> ::vs::VsValueMap_ValueMapEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::VsValueMap_ValueMapEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vs {

// ===================================================================

class KVInfo_KvsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<KVInfo_KvsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<KVInfo_KvsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  KVInfo_KvsEntry_DoNotUse();
  explicit constexpr KVInfo_KvsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit KVInfo_KvsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const KVInfo_KvsEntry_DoNotUse& other);
  static const KVInfo_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const KVInfo_KvsEntry_DoNotUse*>(&_KVInfo_KvsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.KVInfo.KvsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.KVInfo.KvsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class KVInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.KVInfo) */ {
 public:
  inline KVInfo() : KVInfo(nullptr) {}
  ~KVInfo() override;
  explicit constexpr KVInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVInfo(const KVInfo& from);
  KVInfo(KVInfo&& from) noexcept
    : KVInfo() {
    *this = ::std::move(from);
  }

  inline KVInfo& operator=(const KVInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVInfo& operator=(KVInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVInfo* internal_default_instance() {
    return reinterpret_cast<const KVInfo*>(
               &_KVInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KVInfo& a, KVInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(KVInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KVInfo* New() const final {
    return new KVInfo();
  }

  KVInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KVInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KVInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.KVInfo";
  }
  protected:
  explicit KVInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 1,
  };
  // map<string, string> Kvs = 1;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_kvs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_kvs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      kvs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:vs.KVInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      KVInfo_KvsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> kvs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ErrInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.ErrInfo) */ {
 public:
  inline ErrInfo() : ErrInfo(nullptr) {}
  ~ErrInfo() override;
  explicit constexpr ErrInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrInfo(const ErrInfo& from);
  ErrInfo(ErrInfo&& from) noexcept
    : ErrInfo() {
    *this = ::std::move(from);
  }

  inline ErrInfo& operator=(const ErrInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrInfo& operator=(ErrInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrInfo* internal_default_instance() {
    return reinterpret_cast<const ErrInfo*>(
               &_ErrInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ErrInfo& a, ErrInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrInfo* New() const final {
    return new ErrInfo();
  }

  ErrInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ErrInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ErrInfo";
  }
  protected:
  explicit ErrInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrMsgFieldNumber = 2,
    kErrCodeFieldNumber = 1,
  };
  // bytes ErrMsg = 2;
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // int32 ErrCode = 1;
  void clear_errcode();
  ::PROTOBUF_NAMESPACE_ID::int32 errcode() const;
  void set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_errcode() const;
  void _internal_set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.ErrInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::int32 errcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class HeadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.HeadReq) */ {
 public:
  inline HeadReq() : HeadReq(nullptr) {}
  ~HeadReq() override;
  explicit constexpr HeadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeadReq(const HeadReq& from);
  HeadReq(HeadReq&& from) noexcept
    : HeadReq() {
    *this = ::std::move(from);
  }

  inline HeadReq& operator=(const HeadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadReq& operator=(HeadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadReq* internal_default_instance() {
    return reinterpret_cast<const HeadReq*>(
               &_HeadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HeadReq& a, HeadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeadReq* New() const final {
    return new HeadReq();
  }

  HeadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeadReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.HeadReq";
  }
  protected:
  explicit HeadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 5,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kPeriodFieldNumber = 3,
    kReqTypeFieldNumber = 4,
  };
  // bytes TagName = 5;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // int32 Start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Period = 3;
  void clear_period();
  ::PROTOBUF_NAMESPACE_ID::int32 period() const;
  void set_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_period() const;
  void _internal_set_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ReqType = 4;
  void clear_reqtype();
  ::PROTOBUF_NAMESPACE_ID::int32 reqtype() const;
  void set_reqtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_reqtype() const;
  void _internal_set_reqtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.HeadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  ::PROTOBUF_NAMESPACE_ID::int32 period_;
  ::PROTOBUF_NAMESPACE_ID::int32 reqtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagFractureSectionGetReq_ExtendsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagFractureSectionGetReq_ExtendsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagFractureSectionGetReq_ExtendsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TagFractureSectionGetReq_ExtendsEntry_DoNotUse();
  explicit constexpr TagFractureSectionGetReq_ExtendsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagFractureSectionGetReq_ExtendsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagFractureSectionGetReq_ExtendsEntry_DoNotUse& other);
  static const TagFractureSectionGetReq_ExtendsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagFractureSectionGetReq_ExtendsEntry_DoNotUse*>(&_TagFractureSectionGetReq_ExtendsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagFractureSectionGetReq.ExtendsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagFractureSectionGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagFractureSectionGetReq) */ {
 public:
  inline TagFractureSectionGetReq() : TagFractureSectionGetReq(nullptr) {}
  ~TagFractureSectionGetReq() override;
  explicit constexpr TagFractureSectionGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagFractureSectionGetReq(const TagFractureSectionGetReq& from);
  TagFractureSectionGetReq(TagFractureSectionGetReq&& from) noexcept
    : TagFractureSectionGetReq() {
    *this = ::std::move(from);
  }

  inline TagFractureSectionGetReq& operator=(const TagFractureSectionGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagFractureSectionGetReq& operator=(TagFractureSectionGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagFractureSectionGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagFractureSectionGetReq* internal_default_instance() {
    return reinterpret_cast<const TagFractureSectionGetReq*>(
               &_TagFractureSectionGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TagFractureSectionGetReq& a, TagFractureSectionGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagFractureSectionGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagFractureSectionGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagFractureSectionGetReq* New() const final {
    return new TagFractureSectionGetReq();
  }

  TagFractureSectionGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagFractureSectionGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagFractureSectionGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagFractureSectionGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagFractureSectionGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagFractureSectionGetReq";
  }
  protected:
  explicit TagFractureSectionGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtendsFieldNumber = 4,
    kKvsFieldNumber = 1,
    kHeadFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // map<string, bytes> Extends = 4;
  int extends_size() const;
  private:
  int _internal_extends_size() const;
  public:
  void clear_extends();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extends() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extends();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extends() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extends();

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // .vs.HeadReq Head = 2;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vs::HeadReq& head() const;
  PROTOBUF_MUST_USE_RESULT ::vs::HeadReq* release_head();
  ::vs::HeadReq* mutable_head();
  void set_allocated_head(::vs::HeadReq* head);
  private:
  const ::vs::HeadReq& _internal_head() const;
  ::vs::HeadReq* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vs::HeadReq* head);
  ::vs::HeadReq* unsafe_arena_release_head();

  // int32 Count = 3;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagFractureSectionGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagFractureSectionGetReq_ExtendsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> extends_;
  ::vs::KVInfo* kvs_;
  ::vs::HeadReq* head_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class VsValueMap_ValueMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VsValueMap_ValueMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VsValueMap_ValueMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  VsValueMap_ValueMapEntry_DoNotUse();
  explicit constexpr VsValueMap_ValueMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit VsValueMap_ValueMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const VsValueMap_ValueMapEntry_DoNotUse& other);
  static const VsValueMap_ValueMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const VsValueMap_ValueMapEntry_DoNotUse*>(&_VsValueMap_ValueMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.VsValueMap.ValueMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class VsValueMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.VsValueMap) */ {
 public:
  inline VsValueMap() : VsValueMap(nullptr) {}
  ~VsValueMap() override;
  explicit constexpr VsValueMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VsValueMap(const VsValueMap& from);
  VsValueMap(VsValueMap&& from) noexcept
    : VsValueMap() {
    *this = ::std::move(from);
  }

  inline VsValueMap& operator=(const VsValueMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline VsValueMap& operator=(VsValueMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VsValueMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const VsValueMap* internal_default_instance() {
    return reinterpret_cast<const VsValueMap*>(
               &_VsValueMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VsValueMap& a, VsValueMap& b) {
    a.Swap(&b);
  }
  inline void Swap(VsValueMap* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VsValueMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VsValueMap* New() const final {
    return new VsValueMap();
  }

  VsValueMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VsValueMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VsValueMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VsValueMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VsValueMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.VsValueMap";
  }
  protected:
  explicit VsValueMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValueMapFieldNumber = 1,
  };
  // map<string, bytes> ValueMap = 1;
  int valuemap_size() const;
  private:
  int _internal_valuemap_size() const;
  public:
  void clear_valuemap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_valuemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_valuemap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      valuemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_valuemap();

  // @@protoc_insertion_point(class_scope:vs.VsValueMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      VsValueMap_ValueMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> valuemap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagFractureSectionGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagFractureSectionGetResp) */ {
 public:
  inline TagFractureSectionGetResp() : TagFractureSectionGetResp(nullptr) {}
  ~TagFractureSectionGetResp() override;
  explicit constexpr TagFractureSectionGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagFractureSectionGetResp(const TagFractureSectionGetResp& from);
  TagFractureSectionGetResp(TagFractureSectionGetResp&& from) noexcept
    : TagFractureSectionGetResp() {
    *this = ::std::move(from);
  }

  inline TagFractureSectionGetResp& operator=(const TagFractureSectionGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagFractureSectionGetResp& operator=(TagFractureSectionGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagFractureSectionGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagFractureSectionGetResp* internal_default_instance() {
    return reinterpret_cast<const TagFractureSectionGetResp*>(
               &_TagFractureSectionGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TagFractureSectionGetResp& a, TagFractureSectionGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagFractureSectionGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagFractureSectionGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagFractureSectionGetResp* New() const final {
    return new TagFractureSectionGetResp();
  }

  TagFractureSectionGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagFractureSectionGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagFractureSectionGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagFractureSectionGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagFractureSectionGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagFractureSectionGetResp";
  }
  protected:
  explicit TagFractureSectionGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kValueTypeFieldNumber = 3,
    kErrFieldNumber = 1,
    kStartFieldNumber = 4,
    kEndFieldNumber = 5,
  };
  // repeated .vs.VsValueMap Values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::vs::VsValueMap* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
      mutable_values();
  private:
  const ::vs::VsValueMap& _internal_values(int index) const;
  ::vs::VsValueMap* _internal_add_values();
  public:
  const ::vs::VsValueMap& values(int index) const;
  ::vs::VsValueMap* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
      values() const;

  // string ValueType = 3;
  void clear_valuetype();
  const std::string& valuetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valuetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valuetype();
  PROTOBUF_MUST_USE_RESULT std::string* release_valuetype();
  void set_allocated_valuetype(std::string* valuetype);
  private:
  const std::string& _internal_valuetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valuetype(const std::string& value);
  std::string* _internal_mutable_valuetype();
  public:

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 4;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 5;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagFractureSectionGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valuetype_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagCountByRangeGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagCountByRangeGetReq) */ {
 public:
  inline TagCountByRangeGetReq() : TagCountByRangeGetReq(nullptr) {}
  ~TagCountByRangeGetReq() override;
  explicit constexpr TagCountByRangeGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagCountByRangeGetReq(const TagCountByRangeGetReq& from);
  TagCountByRangeGetReq(TagCountByRangeGetReq&& from) noexcept
    : TagCountByRangeGetReq() {
    *this = ::std::move(from);
  }

  inline TagCountByRangeGetReq& operator=(const TagCountByRangeGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagCountByRangeGetReq& operator=(TagCountByRangeGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagCountByRangeGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagCountByRangeGetReq* internal_default_instance() {
    return reinterpret_cast<const TagCountByRangeGetReq*>(
               &_TagCountByRangeGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TagCountByRangeGetReq& a, TagCountByRangeGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagCountByRangeGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagCountByRangeGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagCountByRangeGetReq* New() const final {
    return new TagCountByRangeGetReq();
  }

  TagCountByRangeGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagCountByRangeGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagCountByRangeGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagCountByRangeGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagCountByRangeGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagCountByRangeGetReq";
  }
  protected:
  explicit TagCountByRangeGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 4,
    kKvsFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kCountFieldNumber = 5,
  };
  // bytes TagName = 4;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Start = 2;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 3;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Count = 5;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagCountByRangeGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagCountByRangeGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagCountByRangeGetResp) */ {
 public:
  inline TagCountByRangeGetResp() : TagCountByRangeGetResp(nullptr) {}
  ~TagCountByRangeGetResp() override;
  explicit constexpr TagCountByRangeGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagCountByRangeGetResp(const TagCountByRangeGetResp& from);
  TagCountByRangeGetResp(TagCountByRangeGetResp&& from) noexcept
    : TagCountByRangeGetResp() {
    *this = ::std::move(from);
  }

  inline TagCountByRangeGetResp& operator=(const TagCountByRangeGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagCountByRangeGetResp& operator=(TagCountByRangeGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagCountByRangeGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagCountByRangeGetResp* internal_default_instance() {
    return reinterpret_cast<const TagCountByRangeGetResp*>(
               &_TagCountByRangeGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TagCountByRangeGetResp& a, TagCountByRangeGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagCountByRangeGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagCountByRangeGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagCountByRangeGetResp* New() const final {
    return new TagCountByRangeGetResp();
  }

  TagCountByRangeGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagCountByRangeGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagCountByRangeGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagCountByRangeGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagCountByRangeGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagCountByRangeGetResp";
  }
  protected:
  explicit TagCountByRangeGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Count = 2;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagCountByRangeGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagListGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagListGetReq) */ {
 public:
  inline TagListGetReq() : TagListGetReq(nullptr) {}
  ~TagListGetReq() override;
  explicit constexpr TagListGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagListGetReq(const TagListGetReq& from);
  TagListGetReq(TagListGetReq&& from) noexcept
    : TagListGetReq() {
    *this = ::std::move(from);
  }

  inline TagListGetReq& operator=(const TagListGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListGetReq& operator=(TagListGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListGetReq* internal_default_instance() {
    return reinterpret_cast<const TagListGetReq*>(
               &_TagListGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TagListGetReq& a, TagListGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagListGetReq* New() const final {
    return new TagListGetReq();
  }

  TagListGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagListGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagListGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagListGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagListGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagListGetReq";
  }
  protected:
  explicit TagListGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 1,
    kPageFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Page = 2;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::int32 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_page() const;
  void _internal_set_page(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Size = 3;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagListGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 page_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagListGetResp_TagInfoMap_InfosEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagListGetResp_TagInfoMap_InfosEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagListGetResp_TagInfoMap_InfosEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TagListGetResp_TagInfoMap_InfosEntry_DoNotUse();
  explicit constexpr TagListGetResp_TagInfoMap_InfosEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagListGetResp_TagInfoMap_InfosEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagListGetResp_TagInfoMap_InfosEntry_DoNotUse& other);
  static const TagListGetResp_TagInfoMap_InfosEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagListGetResp_TagInfoMap_InfosEntry_DoNotUse*>(&_TagListGetResp_TagInfoMap_InfosEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagListGetResp.TagInfoMap.InfosEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagListGetResp_TagInfoMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagListGetResp.TagInfoMap) */ {
 public:
  inline TagListGetResp_TagInfoMap() : TagListGetResp_TagInfoMap(nullptr) {}
  ~TagListGetResp_TagInfoMap() override;
  explicit constexpr TagListGetResp_TagInfoMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagListGetResp_TagInfoMap(const TagListGetResp_TagInfoMap& from);
  TagListGetResp_TagInfoMap(TagListGetResp_TagInfoMap&& from) noexcept
    : TagListGetResp_TagInfoMap() {
    *this = ::std::move(from);
  }

  inline TagListGetResp_TagInfoMap& operator=(const TagListGetResp_TagInfoMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListGetResp_TagInfoMap& operator=(TagListGetResp_TagInfoMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListGetResp_TagInfoMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListGetResp_TagInfoMap* internal_default_instance() {
    return reinterpret_cast<const TagListGetResp_TagInfoMap*>(
               &_TagListGetResp_TagInfoMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TagListGetResp_TagInfoMap& a, TagListGetResp_TagInfoMap& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListGetResp_TagInfoMap* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListGetResp_TagInfoMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagListGetResp_TagInfoMap* New() const final {
    return new TagListGetResp_TagInfoMap();
  }

  TagListGetResp_TagInfoMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagListGetResp_TagInfoMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagListGetResp_TagInfoMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagListGetResp_TagInfoMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagListGetResp_TagInfoMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagListGetResp.TagInfoMap";
  }
  protected:
  explicit TagListGetResp_TagInfoMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 1,
  };
  // map<string, bytes> Infos = 1;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_infos() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_infos();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      infos() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:vs.TagListGetResp.TagInfoMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagListGetResp_TagInfoMap_InfosEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> infos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagListGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagListGetResp) */ {
 public:
  inline TagListGetResp() : TagListGetResp(nullptr) {}
  ~TagListGetResp() override;
  explicit constexpr TagListGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagListGetResp(const TagListGetResp& from);
  TagListGetResp(TagListGetResp&& from) noexcept
    : TagListGetResp() {
    *this = ::std::move(from);
  }

  inline TagListGetResp& operator=(const TagListGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListGetResp& operator=(TagListGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListGetResp* internal_default_instance() {
    return reinterpret_cast<const TagListGetResp*>(
               &_TagListGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TagListGetResp& a, TagListGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagListGetResp* New() const final {
    return new TagListGetResp();
  }

  TagListGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagListGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagListGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagListGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagListGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagListGetResp";
  }
  protected:
  explicit TagListGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TagListGetResp_TagInfoMap TagInfoMap;

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 2,
    kErrFieldNumber = 1,
  };
  // repeated .vs.TagListGetResp.TagInfoMap Tags = 2;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::vs::TagListGetResp_TagInfoMap* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >*
      mutable_tags();
  private:
  const ::vs::TagListGetResp_TagInfoMap& _internal_tags(int index) const;
  ::vs::TagListGetResp_TagInfoMap* _internal_add_tags();
  public:
  const ::vs::TagListGetResp_TagInfoMap& tags(int index) const;
  ::vs::TagListGetResp_TagInfoMap* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >&
      tags() const;

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:vs.TagListGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap > tags_;
  ::vs::ErrInfo* err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class DbPingReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.DbPingReq) */ {
 public:
  inline DbPingReq() : DbPingReq(nullptr) {}
  ~DbPingReq() override;
  explicit constexpr DbPingReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DbPingReq(const DbPingReq& from);
  DbPingReq(DbPingReq&& from) noexcept
    : DbPingReq() {
    *this = ::std::move(from);
  }

  inline DbPingReq& operator=(const DbPingReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DbPingReq& operator=(DbPingReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DbPingReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DbPingReq* internal_default_instance() {
    return reinterpret_cast<const DbPingReq*>(
               &_DbPingReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DbPingReq& a, DbPingReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DbPingReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DbPingReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DbPingReq* New() const final {
    return new DbPingReq();
  }

  DbPingReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DbPingReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DbPingReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DbPingReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DbPingReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.DbPingReq";
  }
  protected:
  explicit DbPingReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 1,
  };
  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // @@protoc_insertion_point(class_scope:vs.DbPingReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vs::KVInfo* kvs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class DbPingResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.DbPingResp) */ {
 public:
  inline DbPingResp() : DbPingResp(nullptr) {}
  ~DbPingResp() override;
  explicit constexpr DbPingResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DbPingResp(const DbPingResp& from);
  DbPingResp(DbPingResp&& from) noexcept
    : DbPingResp() {
    *this = ::std::move(from);
  }

  inline DbPingResp& operator=(const DbPingResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DbPingResp& operator=(DbPingResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DbPingResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DbPingResp* internal_default_instance() {
    return reinterpret_cast<const DbPingResp*>(
               &_DbPingResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DbPingResp& a, DbPingResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DbPingResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DbPingResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DbPingResp* New() const final {
    return new DbPingResp();
  }

  DbPingResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DbPingResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DbPingResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DbPingResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DbPingResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.DbPingResp";
  }
  protected:
  explicit DbPingResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
    kFlagFieldNumber = 2,
  };
  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Flag = 2;
  void clear_flag();
  ::PROTOBUF_NAMESPACE_ID::int32 flag() const;
  void set_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flag() const;
  void _internal_set_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.DbPingResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 flag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class VsValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.VsValue) */ {
 public:
  inline VsValue() : VsValue(nullptr) {}
  ~VsValue() override;
  explicit constexpr VsValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VsValue(const VsValue& from);
  VsValue(VsValue&& from) noexcept
    : VsValue() {
    *this = ::std::move(from);
  }

  inline VsValue& operator=(const VsValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline VsValue& operator=(VsValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VsValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const VsValue* internal_default_instance() {
    return reinterpret_cast<const VsValue*>(
               &_VsValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VsValue& a, VsValue& b) {
    a.Swap(&b);
  }
  inline void Swap(VsValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VsValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VsValue* New() const final {
    return new VsValue();
  }

  VsValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VsValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VsValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VsValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VsValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.VsValue";
  }
  protected:
  explicit VsValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTimeFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // double Value = 1;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // int32 Time = 2;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Status = 3;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.VsValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double value_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesByCountGetReq_MetaEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesByCountGetReq_MetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesByCountGetReq_MetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TagValuesByCountGetReq_MetaEntry_DoNotUse();
  explicit constexpr TagValuesByCountGetReq_MetaEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagValuesByCountGetReq_MetaEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagValuesByCountGetReq_MetaEntry_DoNotUse& other);
  static const TagValuesByCountGetReq_MetaEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagValuesByCountGetReq_MetaEntry_DoNotUse*>(&_TagValuesByCountGetReq_MetaEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesByCountGetReq.MetaEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagValuesByCountGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesByCountGetReq) */ {
 public:
  inline TagValuesByCountGetReq() : TagValuesByCountGetReq(nullptr) {}
  ~TagValuesByCountGetReq() override;
  explicit constexpr TagValuesByCountGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesByCountGetReq(const TagValuesByCountGetReq& from);
  TagValuesByCountGetReq(TagValuesByCountGetReq&& from) noexcept
    : TagValuesByCountGetReq() {
    *this = ::std::move(from);
  }

  inline TagValuesByCountGetReq& operator=(const TagValuesByCountGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesByCountGetReq& operator=(TagValuesByCountGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesByCountGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesByCountGetReq* internal_default_instance() {
    return reinterpret_cast<const TagValuesByCountGetReq*>(
               &_TagValuesByCountGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TagValuesByCountGetReq& a, TagValuesByCountGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesByCountGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesByCountGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesByCountGetReq* New() const final {
    return new TagValuesByCountGetReq();
  }

  TagValuesByCountGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesByCountGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesByCountGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesByCountGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesByCountGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesByCountGetReq";
  }
  protected:
  explicit TagValuesByCountGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 4,
    kKvsFieldNumber = 1,
    kHeadFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // map<string, bytes> Meta = 4;
  int meta_size() const;
  private:
  int _internal_meta_size() const;
  public:
  void clear_meta();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_meta();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_meta();

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // .vs.HeadReq Head = 2;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vs::HeadReq& head() const;
  PROTOBUF_MUST_USE_RESULT ::vs::HeadReq* release_head();
  ::vs::HeadReq* mutable_head();
  void set_allocated_head(::vs::HeadReq* head);
  private:
  const ::vs::HeadReq& _internal_head() const;
  ::vs::HeadReq* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vs::HeadReq* head);
  ::vs::HeadReq* unsafe_arena_release_head();

  // int32 Count = 3;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagValuesByCountGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagValuesByCountGetReq_MetaEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> meta_;
  ::vs::KVInfo* kvs_;
  ::vs::HeadReq* head_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesByCountGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesByCountGetResp) */ {
 public:
  inline TagValuesByCountGetResp() : TagValuesByCountGetResp(nullptr) {}
  ~TagValuesByCountGetResp() override;
  explicit constexpr TagValuesByCountGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesByCountGetResp(const TagValuesByCountGetResp& from);
  TagValuesByCountGetResp(TagValuesByCountGetResp&& from) noexcept
    : TagValuesByCountGetResp() {
    *this = ::std::move(from);
  }

  inline TagValuesByCountGetResp& operator=(const TagValuesByCountGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesByCountGetResp& operator=(TagValuesByCountGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesByCountGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesByCountGetResp* internal_default_instance() {
    return reinterpret_cast<const TagValuesByCountGetResp*>(
               &_TagValuesByCountGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TagValuesByCountGetResp& a, TagValuesByCountGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesByCountGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesByCountGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesByCountGetResp* New() const final {
    return new TagValuesByCountGetResp();
  }

  TagValuesByCountGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesByCountGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesByCountGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesByCountGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesByCountGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesByCountGetResp";
  }
  protected:
  explicit TagValuesByCountGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kValueTypeFieldNumber = 3,
    kErrFieldNumber = 1,
    kStartFieldNumber = 4,
    kEndFieldNumber = 5,
    kIsLastFieldNumber = 6,
  };
  // repeated .vs.VsValueMap Values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::vs::VsValueMap* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
      mutable_values();
  private:
  const ::vs::VsValueMap& _internal_values(int index) const;
  ::vs::VsValueMap* _internal_add_values();
  public:
  const ::vs::VsValueMap& values(int index) const;
  ::vs::VsValueMap* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
      values() const;

  // string ValueType = 3;
  void clear_valuetype();
  const std::string& valuetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valuetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valuetype();
  PROTOBUF_MUST_USE_RESULT std::string* release_valuetype();
  void set_allocated_valuetype(std::string* valuetype);
  private:
  const std::string& _internal_valuetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valuetype(const std::string& value);
  std::string* _internal_mutable_valuetype();
  public:

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 4;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 5;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool IsLast = 6;
  void clear_islast();
  bool islast() const;
  void set_islast(bool value);
  private:
  bool _internal_islast() const;
  void _internal_set_islast(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagValuesByCountGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valuetype_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  bool islast_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesGetReq_ExtendEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesGetReq_ExtendEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesGetReq_ExtendEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TagValuesGetReq_ExtendEntry_DoNotUse();
  explicit constexpr TagValuesGetReq_ExtendEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagValuesGetReq_ExtendEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagValuesGetReq_ExtendEntry_DoNotUse& other);
  static const TagValuesGetReq_ExtendEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagValuesGetReq_ExtendEntry_DoNotUse*>(&_TagValuesGetReq_ExtendEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesGetReq.ExtendEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagValuesGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesGetReq) */ {
 public:
  inline TagValuesGetReq() : TagValuesGetReq(nullptr) {}
  ~TagValuesGetReq() override;
  explicit constexpr TagValuesGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesGetReq(const TagValuesGetReq& from);
  TagValuesGetReq(TagValuesGetReq&& from) noexcept
    : TagValuesGetReq() {
    *this = ::std::move(from);
  }

  inline TagValuesGetReq& operator=(const TagValuesGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesGetReq& operator=(TagValuesGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesGetReq* internal_default_instance() {
    return reinterpret_cast<const TagValuesGetReq*>(
               &_TagValuesGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TagValuesGetReq& a, TagValuesGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesGetReq* New() const final {
    return new TagValuesGetReq();
  }

  TagValuesGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesGetReq";
  }
  protected:
  explicit TagValuesGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtendFieldNumber = 3,
    kKvsFieldNumber = 1,
    kHeadFieldNumber = 2,
  };
  // map<string, bytes> Extend = 3;
  int extend_size() const;
  private:
  int _internal_extend_size() const;
  public:
  void clear_extend();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extend() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extend();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extend() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extend();

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // .vs.HeadReq Head = 2;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::vs::HeadReq& head() const;
  PROTOBUF_MUST_USE_RESULT ::vs::HeadReq* release_head();
  ::vs::HeadReq* mutable_head();
  void set_allocated_head(::vs::HeadReq* head);
  private:
  const ::vs::HeadReq& _internal_head() const;
  ::vs::HeadReq* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::vs::HeadReq* head);
  ::vs::HeadReq* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:vs.TagValuesGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagValuesGetReq_ExtendEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> extend_;
  ::vs::KVInfo* kvs_;
  ::vs::HeadReq* head_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesGetResp) */ {
 public:
  inline TagValuesGetResp() : TagValuesGetResp(nullptr) {}
  ~TagValuesGetResp() override;
  explicit constexpr TagValuesGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesGetResp(const TagValuesGetResp& from);
  TagValuesGetResp(TagValuesGetResp&& from) noexcept
    : TagValuesGetResp() {
    *this = ::std::move(from);
  }

  inline TagValuesGetResp& operator=(const TagValuesGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesGetResp& operator=(TagValuesGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesGetResp* internal_default_instance() {
    return reinterpret_cast<const TagValuesGetResp*>(
               &_TagValuesGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TagValuesGetResp& a, TagValuesGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesGetResp* New() const final {
    return new TagValuesGetResp();
  }

  TagValuesGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesGetResp";
  }
  protected:
  explicit TagValuesGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kErrFieldNumber = 1,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // repeated .vs.VsValueMap Values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::vs::VsValueMap* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
      mutable_values();
  private:
  const ::vs::VsValueMap& _internal_values(int index) const;
  ::vs::VsValueMap* _internal_add_values();
  public:
  const ::vs::VsValueMap& values(int index) const;
  ::vs::VsValueMap* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
      values() const;

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 3;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 4;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagValuesGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap > values_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagFeatureGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagFeatureGetReq) */ {
 public:
  inline TagFeatureGetReq() : TagFeatureGetReq(nullptr) {}
  ~TagFeatureGetReq() override;
  explicit constexpr TagFeatureGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagFeatureGetReq(const TagFeatureGetReq& from);
  TagFeatureGetReq(TagFeatureGetReq&& from) noexcept
    : TagFeatureGetReq() {
    *this = ::std::move(from);
  }

  inline TagFeatureGetReq& operator=(const TagFeatureGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagFeatureGetReq& operator=(TagFeatureGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagFeatureGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagFeatureGetReq* internal_default_instance() {
    return reinterpret_cast<const TagFeatureGetReq*>(
               &_TagFeatureGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TagFeatureGetReq& a, TagFeatureGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagFeatureGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagFeatureGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagFeatureGetReq* New() const final {
    return new TagFeatureGetReq();
  }

  TagFeatureGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagFeatureGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagFeatureGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagFeatureGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagFeatureGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagFeatureGetReq";
  }
  protected:
  explicit TagFeatureGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerifiesFieldNumber = 5,
    kTagNameFieldNumber = 4,
    kKvsFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // repeated int32 Verifies = 5;
  int verifies_size() const;
  private:
  int _internal_verifies_size() const;
  public:
  void clear_verifies();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_verifies(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_verifies() const;
  void _internal_add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_verifies();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 verifies(int index) const;
  void set_verifies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      verifies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_verifies();

  // bytes TagName = 4;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int64 Start = 2;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int64 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 End = 3;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int64 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagFeatureGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > verifies_;
  mutable std::atomic<int> _verifies_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagFeatureGetResp_FeatsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagFeatureGetResp_FeatsEntry_DoNotUse, 
    std::string, ::vs::VsValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagFeatureGetResp_FeatsEntry_DoNotUse, 
    std::string, ::vs::VsValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TagFeatureGetResp_FeatsEntry_DoNotUse();
  explicit constexpr TagFeatureGetResp_FeatsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagFeatureGetResp_FeatsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagFeatureGetResp_FeatsEntry_DoNotUse& other);
  static const TagFeatureGetResp_FeatsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagFeatureGetResp_FeatsEntry_DoNotUse*>(&_TagFeatureGetResp_FeatsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagFeatureGetResp.FeatsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagFeatureGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagFeatureGetResp) */ {
 public:
  inline TagFeatureGetResp() : TagFeatureGetResp(nullptr) {}
  ~TagFeatureGetResp() override;
  explicit constexpr TagFeatureGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagFeatureGetResp(const TagFeatureGetResp& from);
  TagFeatureGetResp(TagFeatureGetResp&& from) noexcept
    : TagFeatureGetResp() {
    *this = ::std::move(from);
  }

  inline TagFeatureGetResp& operator=(const TagFeatureGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagFeatureGetResp& operator=(TagFeatureGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagFeatureGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagFeatureGetResp* internal_default_instance() {
    return reinterpret_cast<const TagFeatureGetResp*>(
               &_TagFeatureGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TagFeatureGetResp& a, TagFeatureGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagFeatureGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagFeatureGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagFeatureGetResp* New() const final {
    return new TagFeatureGetResp();
  }

  TagFeatureGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagFeatureGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagFeatureGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagFeatureGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagFeatureGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagFeatureGetResp";
  }
  protected:
  explicit TagFeatureGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFeatsFieldNumber = 2,
    kErrFieldNumber = 1,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // map<string, .vs.VsValue> Feats = 2;
  int feats_size() const;
  private:
  int _internal_feats_size() const;
  public:
  void clear_feats();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
      _internal_feats() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
      _internal_mutable_feats();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
      feats() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
      mutable_feats();

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 3;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 4;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagFeatureGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagFeatureGetResp_FeatsEntry_DoNotUse,
      std::string, ::vs::VsValue,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> feats_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagDescGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagDescGetReq) */ {
 public:
  inline TagDescGetReq() : TagDescGetReq(nullptr) {}
  ~TagDescGetReq() override;
  explicit constexpr TagDescGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagDescGetReq(const TagDescGetReq& from);
  TagDescGetReq(TagDescGetReq&& from) noexcept
    : TagDescGetReq() {
    *this = ::std::move(from);
  }

  inline TagDescGetReq& operator=(const TagDescGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagDescGetReq& operator=(TagDescGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagDescGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagDescGetReq* internal_default_instance() {
    return reinterpret_cast<const TagDescGetReq*>(
               &_TagDescGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TagDescGetReq& a, TagDescGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagDescGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagDescGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagDescGetReq* New() const final {
    return new TagDescGetReq();
  }

  TagDescGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagDescGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagDescGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagDescGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagDescGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagDescGetReq";
  }
  protected:
  explicit TagDescGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 2,
    kKvsFieldNumber = 1,
  };
  // bytes TagName = 2;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // @@protoc_insertion_point(class_scope:vs.TagDescGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::vs::KVInfo* kvs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagDescGetResp_DescEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagDescGetResp_DescEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagDescGetResp_DescEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  TagDescGetResp_DescEntry_DoNotUse();
  explicit constexpr TagDescGetResp_DescEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagDescGetResp_DescEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagDescGetResp_DescEntry_DoNotUse& other);
  static const TagDescGetResp_DescEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagDescGetResp_DescEntry_DoNotUse*>(&_TagDescGetResp_DescEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagDescGetResp.DescEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagDescGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagDescGetResp) */ {
 public:
  inline TagDescGetResp() : TagDescGetResp(nullptr) {}
  ~TagDescGetResp() override;
  explicit constexpr TagDescGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagDescGetResp(const TagDescGetResp& from);
  TagDescGetResp(TagDescGetResp&& from) noexcept
    : TagDescGetResp() {
    *this = ::std::move(from);
  }

  inline TagDescGetResp& operator=(const TagDescGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagDescGetResp& operator=(TagDescGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagDescGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagDescGetResp* internal_default_instance() {
    return reinterpret_cast<const TagDescGetResp*>(
               &_TagDescGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TagDescGetResp& a, TagDescGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagDescGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagDescGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagDescGetResp* New() const final {
    return new TagDescGetResp();
  }

  TagDescGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagDescGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagDescGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagDescGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagDescGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagDescGetResp";
  }
  protected:
  explicit TagDescGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDescFieldNumber = 2,
    kTagNameFieldNumber = 1,
  };
  // map<string, bytes> Desc = 2;
  int desc_size() const;
  private:
  int _internal_desc_size() const;
  public:
  void clear_desc();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_desc() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_desc();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      desc() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_desc();

  // bytes TagName = 1;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // @@protoc_insertion_point(class_scope:vs.TagDescGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagDescGetResp_DescEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagTimeSectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagTimeSectionReq) */ {
 public:
  inline TagTimeSectionReq() : TagTimeSectionReq(nullptr) {}
  ~TagTimeSectionReq() override;
  explicit constexpr TagTimeSectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagTimeSectionReq(const TagTimeSectionReq& from);
  TagTimeSectionReq(TagTimeSectionReq&& from) noexcept
    : TagTimeSectionReq() {
    *this = ::std::move(from);
  }

  inline TagTimeSectionReq& operator=(const TagTimeSectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTimeSectionReq& operator=(TagTimeSectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTimeSectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTimeSectionReq* internal_default_instance() {
    return reinterpret_cast<const TagTimeSectionReq*>(
               &_TagTimeSectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TagTimeSectionReq& a, TagTimeSectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTimeSectionReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTimeSectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagTimeSectionReq* New() const final {
    return new TagTimeSectionReq();
  }

  TagTimeSectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagTimeSectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagTimeSectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagTimeSectionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTimeSectionReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagTimeSectionReq";
  }
  protected:
  explicit TagTimeSectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 2,
    kKvsFieldNumber = 1,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // bytes TagName = 2;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Start = 3;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 4;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagTimeSectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagTimeSectionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagTimeSectionResp) */ {
 public:
  inline TagTimeSectionResp() : TagTimeSectionResp(nullptr) {}
  ~TagTimeSectionResp() override;
  explicit constexpr TagTimeSectionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagTimeSectionResp(const TagTimeSectionResp& from);
  TagTimeSectionResp(TagTimeSectionResp&& from) noexcept
    : TagTimeSectionResp() {
    *this = ::std::move(from);
  }

  inline TagTimeSectionResp& operator=(const TagTimeSectionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTimeSectionResp& operator=(TagTimeSectionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTimeSectionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTimeSectionResp* internal_default_instance() {
    return reinterpret_cast<const TagTimeSectionResp*>(
               &_TagTimeSectionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TagTimeSectionResp& a, TagTimeSectionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTimeSectionResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTimeSectionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagTimeSectionResp* New() const final {
    return new TagTimeSectionResp();
  }

  TagTimeSectionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagTimeSectionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagTimeSectionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagTimeSectionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTimeSectionResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagTimeSectionResp";
  }
  protected:
  explicit TagTimeSectionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 2;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 3;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagTimeSectionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ServiceStopReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vs.ServiceStopReq) */ {
 public:
  inline ServiceStopReq() : ServiceStopReq(nullptr) {}
  explicit constexpr ServiceStopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceStopReq(const ServiceStopReq& from);
  ServiceStopReq(ServiceStopReq&& from) noexcept
    : ServiceStopReq() {
    *this = ::std::move(from);
  }

  inline ServiceStopReq& operator=(const ServiceStopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceStopReq& operator=(ServiceStopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceStopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceStopReq* internal_default_instance() {
    return reinterpret_cast<const ServiceStopReq*>(
               &_ServiceStopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ServiceStopReq& a, ServiceStopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceStopReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceStopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServiceStopReq* New() const final {
    return new ServiceStopReq();
  }

  ServiceStopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServiceStopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServiceStopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServiceStopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ServiceStopReq";
  }
  protected:
  explicit ServiceStopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vs.ServiceStopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ServiceStopResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vs.ServiceStopResp) */ {
 public:
  inline ServiceStopResp() : ServiceStopResp(nullptr) {}
  explicit constexpr ServiceStopResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceStopResp(const ServiceStopResp& from);
  ServiceStopResp(ServiceStopResp&& from) noexcept
    : ServiceStopResp() {
    *this = ::std::move(from);
  }

  inline ServiceStopResp& operator=(const ServiceStopResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceStopResp& operator=(ServiceStopResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceStopResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceStopResp* internal_default_instance() {
    return reinterpret_cast<const ServiceStopResp*>(
               &_ServiceStopResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ServiceStopResp& a, ServiceStopResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceStopResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceStopResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServiceStopResp* New() const final {
    return new ServiceStopResp();
  }

  ServiceStopResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServiceStopResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ServiceStopResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ServiceStopResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ServiceStopResp";
  }
  protected:
  explicit ServiceStopResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vs.ServiceStopResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseConnectReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vs.ReleaseConnectReq) */ {
 public:
  inline ReleaseConnectReq() : ReleaseConnectReq(nullptr) {}
  explicit constexpr ReleaseConnectReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseConnectReq(const ReleaseConnectReq& from);
  ReleaseConnectReq(ReleaseConnectReq&& from) noexcept
    : ReleaseConnectReq() {
    *this = ::std::move(from);
  }

  inline ReleaseConnectReq& operator=(const ReleaseConnectReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseConnectReq& operator=(ReleaseConnectReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseConnectReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseConnectReq* internal_default_instance() {
    return reinterpret_cast<const ReleaseConnectReq*>(
               &_ReleaseConnectReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ReleaseConnectReq& a, ReleaseConnectReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseConnectReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseConnectReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseConnectReq* New() const final {
    return new ReleaseConnectReq();
  }

  ReleaseConnectReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseConnectReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReleaseConnectReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReleaseConnectReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ReleaseConnectReq";
  }
  protected:
  explicit ReleaseConnectReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vs.ReleaseConnectReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ReleaseConnectResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vs.ReleaseConnectResp) */ {
 public:
  inline ReleaseConnectResp() : ReleaseConnectResp(nullptr) {}
  explicit constexpr ReleaseConnectResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseConnectResp(const ReleaseConnectResp& from);
  ReleaseConnectResp(ReleaseConnectResp&& from) noexcept
    : ReleaseConnectResp() {
    *this = ::std::move(from);
  }

  inline ReleaseConnectResp& operator=(const ReleaseConnectResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseConnectResp& operator=(ReleaseConnectResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseConnectResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseConnectResp* internal_default_instance() {
    return reinterpret_cast<const ReleaseConnectResp*>(
               &_ReleaseConnectResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ReleaseConnectResp& a, ReleaseConnectResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseConnectResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseConnectResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseConnectResp* New() const final {
    return new ReleaseConnectResp();
  }

  ReleaseConnectResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseConnectResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReleaseConnectResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReleaseConnectResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ReleaseConnectResp";
  }
  protected:
  explicit ReleaseConnectResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vs.ReleaseConnectResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagSnapshotValueReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagSnapshotValueReq) */ {
 public:
  inline TagSnapshotValueReq() : TagSnapshotValueReq(nullptr) {}
  ~TagSnapshotValueReq() override;
  explicit constexpr TagSnapshotValueReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagSnapshotValueReq(const TagSnapshotValueReq& from);
  TagSnapshotValueReq(TagSnapshotValueReq&& from) noexcept
    : TagSnapshotValueReq() {
    *this = ::std::move(from);
  }

  inline TagSnapshotValueReq& operator=(const TagSnapshotValueReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagSnapshotValueReq& operator=(TagSnapshotValueReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagSnapshotValueReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagSnapshotValueReq* internal_default_instance() {
    return reinterpret_cast<const TagSnapshotValueReq*>(
               &_TagSnapshotValueReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TagSnapshotValueReq& a, TagSnapshotValueReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagSnapshotValueReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagSnapshotValueReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagSnapshotValueReq* New() const final {
    return new TagSnapshotValueReq();
  }

  TagSnapshotValueReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagSnapshotValueReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagSnapshotValueReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagSnapshotValueReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagSnapshotValueReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagSnapshotValueReq";
  }
  protected:
  explicit TagSnapshotValueReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 2,
    kKvsFieldNumber = 1,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // bytes TagName = 2;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Start = 3;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 4;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagSnapshotValueReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagSnapshotValueResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagSnapshotValueResp) */ {
 public:
  inline TagSnapshotValueResp() : TagSnapshotValueResp(nullptr) {}
  ~TagSnapshotValueResp() override;
  explicit constexpr TagSnapshotValueResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagSnapshotValueResp(const TagSnapshotValueResp& from);
  TagSnapshotValueResp(TagSnapshotValueResp&& from) noexcept
    : TagSnapshotValueResp() {
    *this = ::std::move(from);
  }

  inline TagSnapshotValueResp& operator=(const TagSnapshotValueResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagSnapshotValueResp& operator=(TagSnapshotValueResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagSnapshotValueResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagSnapshotValueResp* internal_default_instance() {
    return reinterpret_cast<const TagSnapshotValueResp*>(
               &_TagSnapshotValueResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TagSnapshotValueResp& a, TagSnapshotValueResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagSnapshotValueResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagSnapshotValueResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagSnapshotValueResp* New() const final {
    return new TagSnapshotValueResp();
  }

  TagSnapshotValueResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagSnapshotValueResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagSnapshotValueResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagSnapshotValueResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagSnapshotValueResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagSnapshotValueResp";
  }
  protected:
  explicit TagSnapshotValueResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
    kValuesFieldNumber = 2,
  };
  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // .vs.VsValueMap Values = 2;
  bool has_values() const;
  private:
  bool _internal_has_values() const;
  public:
  void clear_values();
  const ::vs::VsValueMap& values() const;
  PROTOBUF_MUST_USE_RESULT ::vs::VsValueMap* release_values();
  ::vs::VsValueMap* mutable_values();
  void set_allocated_values(::vs::VsValueMap* values);
  private:
  const ::vs::VsValueMap& _internal_values() const;
  ::vs::VsValueMap* _internal_mutable_values();
  public:
  void unsafe_arena_set_allocated_values(
      ::vs::VsValueMap* values);
  ::vs::VsValueMap* unsafe_arena_release_values();

  // @@protoc_insertion_point(class_scope:vs.TagSnapshotValueResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vs::ErrInfo* err_;
  ::vs::VsValueMap* values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class InsertData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.InsertData) */ {
 public:
  inline InsertData() : InsertData(nullptr) {}
  ~InsertData() override;
  explicit constexpr InsertData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertData(const InsertData& from);
  InsertData(InsertData&& from) noexcept
    : InsertData() {
    *this = ::std::move(from);
  }

  inline InsertData& operator=(const InsertData& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertData& operator=(InsertData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertData& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertData* internal_default_instance() {
    return reinterpret_cast<const InsertData*>(
               &_InsertData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(InsertData& a, InsertData& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertData* New() const final {
    return new InsertData();
  }

  InsertData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.InsertData";
  }
  protected:
  explicit InsertData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 5,
    kTypeFieldNumber = 1,
    kStatusFieldNumber = 2,
    kValueFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // bytes TagName = 5;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // int32 Type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Status = 2;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double Value = 3;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // int32 Time = 4;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.InsertData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  double value_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagAppendRTTagDataByBatchReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagAppendRTTagDataByBatchReq) */ {
 public:
  inline TagAppendRTTagDataByBatchReq() : TagAppendRTTagDataByBatchReq(nullptr) {}
  ~TagAppendRTTagDataByBatchReq() override;
  explicit constexpr TagAppendRTTagDataByBatchReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagAppendRTTagDataByBatchReq(const TagAppendRTTagDataByBatchReq& from);
  TagAppendRTTagDataByBatchReq(TagAppendRTTagDataByBatchReq&& from) noexcept
    : TagAppendRTTagDataByBatchReq() {
    *this = ::std::move(from);
  }

  inline TagAppendRTTagDataByBatchReq& operator=(const TagAppendRTTagDataByBatchReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagAppendRTTagDataByBatchReq& operator=(TagAppendRTTagDataByBatchReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagAppendRTTagDataByBatchReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagAppendRTTagDataByBatchReq* internal_default_instance() {
    return reinterpret_cast<const TagAppendRTTagDataByBatchReq*>(
               &_TagAppendRTTagDataByBatchReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TagAppendRTTagDataByBatchReq& a, TagAppendRTTagDataByBatchReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagAppendRTTagDataByBatchReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagAppendRTTagDataByBatchReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagAppendRTTagDataByBatchReq* New() const final {
    return new TagAppendRTTagDataByBatchReq();
  }

  TagAppendRTTagDataByBatchReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagAppendRTTagDataByBatchReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagAppendRTTagDataByBatchReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagAppendRTTagDataByBatchReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagAppendRTTagDataByBatchReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagAppendRTTagDataByBatchReq";
  }
  protected:
  explicit TagAppendRTTagDataByBatchReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKvsFieldNumber = 1,
  };
  // repeated .vs.InsertData Data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::vs::InsertData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >*
      mutable_data();
  private:
  const ::vs::InsertData& _internal_data(int index) const;
  ::vs::InsertData* _internal_add_data();
  public:
  const ::vs::InsertData& data(int index) const;
  ::vs::InsertData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >&
      data() const;

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // @@protoc_insertion_point(class_scope:vs.TagAppendRTTagDataByBatchReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData > data_;
  ::vs::KVInfo* kvs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagAppendRTTagDataByBatchResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagAppendRTTagDataByBatchResp) */ {
 public:
  inline TagAppendRTTagDataByBatchResp() : TagAppendRTTagDataByBatchResp(nullptr) {}
  ~TagAppendRTTagDataByBatchResp() override;
  explicit constexpr TagAppendRTTagDataByBatchResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagAppendRTTagDataByBatchResp(const TagAppendRTTagDataByBatchResp& from);
  TagAppendRTTagDataByBatchResp(TagAppendRTTagDataByBatchResp&& from) noexcept
    : TagAppendRTTagDataByBatchResp() {
    *this = ::std::move(from);
  }

  inline TagAppendRTTagDataByBatchResp& operator=(const TagAppendRTTagDataByBatchResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagAppendRTTagDataByBatchResp& operator=(TagAppendRTTagDataByBatchResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagAppendRTTagDataByBatchResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagAppendRTTagDataByBatchResp* internal_default_instance() {
    return reinterpret_cast<const TagAppendRTTagDataByBatchResp*>(
               &_TagAppendRTTagDataByBatchResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TagAppendRTTagDataByBatchResp& a, TagAppendRTTagDataByBatchResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagAppendRTTagDataByBatchResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagAppendRTTagDataByBatchResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagAppendRTTagDataByBatchResp* New() const final {
    return new TagAppendRTTagDataByBatchResp();
  }

  TagAppendRTTagDataByBatchResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagAppendRTTagDataByBatchResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagAppendRTTagDataByBatchResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagAppendRTTagDataByBatchResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagAppendRTTagDataByBatchResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagAppendRTTagDataByBatchResp";
  }
  protected:
  explicit TagAppendRTTagDataByBatchResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kErrFieldNumber = 1,
  };
  // repeated .vs.InsertData Data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::vs::InsertData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >*
      mutable_data();
  private:
  const ::vs::InsertData& _internal_data(int index) const;
  ::vs::InsertData* _internal_add_data();
  public:
  const ::vs::InsertData& data(int index) const;
  ::vs::InsertData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >&
      data() const;

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:vs.TagAppendRTTagDataByBatchResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData > data_;
  ::vs::ErrInfo* err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class GetRTDataByBatchReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.GetRTDataByBatchReq) */ {
 public:
  inline GetRTDataByBatchReq() : GetRTDataByBatchReq(nullptr) {}
  ~GetRTDataByBatchReq() override;
  explicit constexpr GetRTDataByBatchReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRTDataByBatchReq(const GetRTDataByBatchReq& from);
  GetRTDataByBatchReq(GetRTDataByBatchReq&& from) noexcept
    : GetRTDataByBatchReq() {
    *this = ::std::move(from);
  }

  inline GetRTDataByBatchReq& operator=(const GetRTDataByBatchReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRTDataByBatchReq& operator=(GetRTDataByBatchReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRTDataByBatchReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRTDataByBatchReq* internal_default_instance() {
    return reinterpret_cast<const GetRTDataByBatchReq*>(
               &_GetRTDataByBatchReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetRTDataByBatchReq& a, GetRTDataByBatchReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRTDataByBatchReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRTDataByBatchReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRTDataByBatchReq* New() const final {
    return new GetRTDataByBatchReq();
  }

  GetRTDataByBatchReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRTDataByBatchReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRTDataByBatchReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRTDataByBatchReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRTDataByBatchReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.GetRTDataByBatchReq";
  }
  protected:
  explicit GetRTDataByBatchReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNamesFieldNumber = 2,
    kKvsFieldNumber = 1,
  };
  // repeated bytes TagNames = 2;
  int tagnames_size() const;
  private:
  int _internal_tagnames_size() const;
  public:
  void clear_tagnames();
  const std::string& tagnames(int index) const;
  std::string* mutable_tagnames(int index);
  void set_tagnames(int index, const std::string& value);
  void set_tagnames(int index, std::string&& value);
  void set_tagnames(int index, const char* value);
  void set_tagnames(int index, const void* value, size_t size);
  std::string* add_tagnames();
  void add_tagnames(const std::string& value);
  void add_tagnames(std::string&& value);
  void add_tagnames(const char* value);
  void add_tagnames(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tagnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tagnames();
  private:
  const std::string& _internal_tagnames(int index) const;
  std::string* _internal_add_tagnames();
  public:

  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // @@protoc_insertion_point(class_scope:vs.GetRTDataByBatchReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tagnames_;
  ::vs::KVInfo* kvs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class GetRTDataByBatchResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.GetRTDataByBatchResp) */ {
 public:
  inline GetRTDataByBatchResp() : GetRTDataByBatchResp(nullptr) {}
  ~GetRTDataByBatchResp() override;
  explicit constexpr GetRTDataByBatchResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRTDataByBatchResp(const GetRTDataByBatchResp& from);
  GetRTDataByBatchResp(GetRTDataByBatchResp&& from) noexcept
    : GetRTDataByBatchResp() {
    *this = ::std::move(from);
  }

  inline GetRTDataByBatchResp& operator=(const GetRTDataByBatchResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRTDataByBatchResp& operator=(GetRTDataByBatchResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRTDataByBatchResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRTDataByBatchResp* internal_default_instance() {
    return reinterpret_cast<const GetRTDataByBatchResp*>(
               &_GetRTDataByBatchResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetRTDataByBatchResp& a, GetRTDataByBatchResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRTDataByBatchResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRTDataByBatchResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRTDataByBatchResp* New() const final {
    return new GetRTDataByBatchResp();
  }

  GetRTDataByBatchResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRTDataByBatchResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRTDataByBatchResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRTDataByBatchResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRTDataByBatchResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.GetRTDataByBatchResp";
  }
  protected:
  explicit GetRTDataByBatchResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kErrFieldNumber = 1,
  };
  // repeated .vs.VsValueMap Values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::vs::VsValueMap* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
      mutable_values();
  private:
  const ::vs::VsValueMap& _internal_values(int index) const;
  ::vs::VsValueMap* _internal_add_values();
  public:
  const ::vs::VsValueMap& values(int index) const;
  ::vs::VsValueMap* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
      values() const;

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:vs.GetRTDataByBatchResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap > values_;
  ::vs::ErrInfo* err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// KVInfo

// map<string, string> Kvs = 1;
inline int KVInfo::_internal_kvs_size() const {
  return kvs_.size();
}
inline int KVInfo::kvs_size() const {
  return _internal_kvs_size();
}
inline void KVInfo::clear_kvs() {
  kvs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
KVInfo::_internal_kvs() const {
  return kvs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
KVInfo::kvs() const {
  // @@protoc_insertion_point(field_map:vs.KVInfo.Kvs)
  return _internal_kvs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
KVInfo::_internal_mutable_kvs() {
  return kvs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
KVInfo::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:vs.KVInfo.Kvs)
  return _internal_mutable_kvs();
}

// -------------------------------------------------------------------

// ErrInfo

// int32 ErrCode = 1;
inline void ErrInfo::clear_errcode() {
  errcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ErrInfo::_internal_errcode() const {
  return errcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ErrInfo::errcode() const {
  // @@protoc_insertion_point(field_get:vs.ErrInfo.ErrCode)
  return _internal_errcode();
}
inline void ErrInfo::_internal_set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  errcode_ = value;
}
inline void ErrInfo::set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:vs.ErrInfo.ErrCode)
}

// bytes ErrMsg = 2;
inline void ErrInfo::clear_errmsg() {
  errmsg_.ClearToEmpty();
}
inline const std::string& ErrInfo::errmsg() const {
  // @@protoc_insertion_point(field_get:vs.ErrInfo.ErrMsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrInfo::set_errmsg(ArgT0&& arg0, ArgT... args) {
 
 errmsg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.ErrInfo.ErrMsg)
}
inline std::string* ErrInfo::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:vs.ErrInfo.ErrMsg)
  return _s;
}
inline const std::string& ErrInfo::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void ErrInfo::_internal_set_errmsg(const std::string& value) {
  
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ErrInfo::_internal_mutable_errmsg() {
  
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ErrInfo::release_errmsg() {
  // @@protoc_insertion_point(field_release:vs.ErrInfo.ErrMsg)
  return errmsg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ErrInfo::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    
  } else {
    
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.ErrInfo.ErrMsg)
}

// -------------------------------------------------------------------

// HeadReq

// int32 Start = 1;
inline void HeadReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::start() const {
  // @@protoc_insertion_point(field_get:vs.HeadReq.Start)
  return _internal_start();
}
inline void HeadReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void HeadReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.HeadReq.Start)
}

// int32 End = 2;
inline void HeadReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::end() const {
  // @@protoc_insertion_point(field_get:vs.HeadReq.End)
  return _internal_end();
}
inline void HeadReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void HeadReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.HeadReq.End)
}

// int32 Period = 3;
inline void HeadReq::clear_period() {
  period_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::_internal_period() const {
  return period_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::period() const {
  // @@protoc_insertion_point(field_get:vs.HeadReq.Period)
  return _internal_period();
}
inline void HeadReq::_internal_set_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  period_ = value;
}
inline void HeadReq::set_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:vs.HeadReq.Period)
}

// int32 ReqType = 4;
inline void HeadReq::clear_reqtype() {
  reqtype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::_internal_reqtype() const {
  return reqtype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HeadReq::reqtype() const {
  // @@protoc_insertion_point(field_get:vs.HeadReq.ReqType)
  return _internal_reqtype();
}
inline void HeadReq::_internal_set_reqtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  reqtype_ = value;
}
inline void HeadReq::set_reqtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_reqtype(value);
  // @@protoc_insertion_point(field_set:vs.HeadReq.ReqType)
}

// bytes TagName = 5;
inline void HeadReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& HeadReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.HeadReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeadReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.HeadReq.TagName)
}
inline std::string* HeadReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.HeadReq.TagName)
  return _s;
}
inline const std::string& HeadReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void HeadReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HeadReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HeadReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.HeadReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HeadReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.HeadReq.TagName)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagFractureSectionGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagFractureSectionGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagFractureSectionGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagFractureSectionGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagFractureSectionGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagFractureSectionGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetReq.Kvs)
  return _internal_kvs();
}
inline void TagFractureSectionGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagFractureSectionGetReq.Kvs)
}
inline ::vs::KVInfo* TagFractureSectionGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagFractureSectionGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagFractureSectionGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagFractureSectionGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagFractureSectionGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagFractureSectionGetReq.Kvs)
  return _msg;
}
inline void TagFractureSectionGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagFractureSectionGetReq.Kvs)
}

// .vs.HeadReq Head = 2;
inline bool TagFractureSectionGetReq::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool TagFractureSectionGetReq::has_head() const {
  return _internal_has_head();
}
inline void TagFractureSectionGetReq::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::vs::HeadReq& TagFractureSectionGetReq::_internal_head() const {
  const ::vs::HeadReq* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::HeadReq&>(
      ::vs::_HeadReq_default_instance_);
}
inline const ::vs::HeadReq& TagFractureSectionGetReq::head() const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetReq.Head)
  return _internal_head();
}
inline void TagFractureSectionGetReq::unsafe_arena_set_allocated_head(
    ::vs::HeadReq* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagFractureSectionGetReq.Head)
}
inline ::vs::HeadReq* TagFractureSectionGetReq::release_head() {
  
  ::vs::HeadReq* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::HeadReq* TagFractureSectionGetReq::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vs.TagFractureSectionGetReq.Head)
  
  ::vs::HeadReq* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::vs::HeadReq* TagFractureSectionGetReq::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::HeadReq>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::vs::HeadReq* TagFractureSectionGetReq::mutable_head() {
  ::vs::HeadReq* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vs.TagFractureSectionGetReq.Head)
  return _msg;
}
inline void TagFractureSectionGetReq::set_allocated_head(::vs::HeadReq* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::HeadReq>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vs.TagFractureSectionGetReq.Head)
}

// int32 Count = 3;
inline void TagFractureSectionGetReq::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFractureSectionGetReq::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFractureSectionGetReq::count() const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetReq.Count)
  return _internal_count();
}
inline void TagFractureSectionGetReq::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagFractureSectionGetReq::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagFractureSectionGetReq.Count)
}

// map<string, bytes> Extends = 4;
inline int TagFractureSectionGetReq::_internal_extends_size() const {
  return extends_.size();
}
inline int TagFractureSectionGetReq::extends_size() const {
  return _internal_extends_size();
}
inline void TagFractureSectionGetReq::clear_extends() {
  extends_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagFractureSectionGetReq::_internal_extends() const {
  return extends_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagFractureSectionGetReq::extends() const {
  // @@protoc_insertion_point(field_map:vs.TagFractureSectionGetReq.Extends)
  return _internal_extends();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagFractureSectionGetReq::_internal_mutable_extends() {
  return extends_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagFractureSectionGetReq::mutable_extends() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagFractureSectionGetReq.Extends)
  return _internal_mutable_extends();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VsValueMap

// map<string, bytes> ValueMap = 1;
inline int VsValueMap::_internal_valuemap_size() const {
  return valuemap_.size();
}
inline int VsValueMap::valuemap_size() const {
  return _internal_valuemap_size();
}
inline void VsValueMap::clear_valuemap() {
  valuemap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VsValueMap::_internal_valuemap() const {
  return valuemap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VsValueMap::valuemap() const {
  // @@protoc_insertion_point(field_map:vs.VsValueMap.ValueMap)
  return _internal_valuemap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VsValueMap::_internal_mutable_valuemap() {
  return valuemap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VsValueMap::mutable_valuemap() {
  // @@protoc_insertion_point(field_mutable_map:vs.VsValueMap.ValueMap)
  return _internal_mutable_valuemap();
}

// -------------------------------------------------------------------

// TagFractureSectionGetResp

// .vs.ErrInfo Err = 1;
inline bool TagFractureSectionGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagFractureSectionGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagFractureSectionGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagFractureSectionGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagFractureSectionGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetResp.Err)
  return _internal_err();
}
inline void TagFractureSectionGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagFractureSectionGetResp.Err)
}
inline ::vs::ErrInfo* TagFractureSectionGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagFractureSectionGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagFractureSectionGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagFractureSectionGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagFractureSectionGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagFractureSectionGetResp.Err)
  return _msg;
}
inline void TagFractureSectionGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagFractureSectionGetResp.Err)
}

// repeated .vs.VsValueMap Values = 2;
inline int TagFractureSectionGetResp::_internal_values_size() const {
  return values_.size();
}
inline int TagFractureSectionGetResp::values_size() const {
  return _internal_values_size();
}
inline void TagFractureSectionGetResp::clear_values() {
  values_.Clear();
}
inline ::vs::VsValueMap* TagFractureSectionGetResp::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagFractureSectionGetResp.Values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
TagFractureSectionGetResp::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagFractureSectionGetResp.Values)
  return &values_;
}
inline const ::vs::VsValueMap& TagFractureSectionGetResp::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::vs::VsValueMap& TagFractureSectionGetResp::values(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetResp.Values)
  return _internal_values(index);
}
inline ::vs::VsValueMap* TagFractureSectionGetResp::_internal_add_values() {
  return values_.Add();
}
inline ::vs::VsValueMap* TagFractureSectionGetResp::add_values() {
  ::vs::VsValueMap* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:vs.TagFractureSectionGetResp.Values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
TagFractureSectionGetResp::values() const {
  // @@protoc_insertion_point(field_list:vs.TagFractureSectionGetResp.Values)
  return values_;
}

// string ValueType = 3;
inline void TagFractureSectionGetResp::clear_valuetype() {
  valuetype_.ClearToEmpty();
}
inline const std::string& TagFractureSectionGetResp::valuetype() const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetResp.ValueType)
  return _internal_valuetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagFractureSectionGetResp::set_valuetype(ArgT0&& arg0, ArgT... args) {
 
 valuetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagFractureSectionGetResp.ValueType)
}
inline std::string* TagFractureSectionGetResp::mutable_valuetype() {
  std::string* _s = _internal_mutable_valuetype();
  // @@protoc_insertion_point(field_mutable:vs.TagFractureSectionGetResp.ValueType)
  return _s;
}
inline const std::string& TagFractureSectionGetResp::_internal_valuetype() const {
  return valuetype_.Get();
}
inline void TagFractureSectionGetResp::_internal_set_valuetype(const std::string& value) {
  
  valuetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagFractureSectionGetResp::_internal_mutable_valuetype() {
  
  return valuetype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagFractureSectionGetResp::release_valuetype() {
  // @@protoc_insertion_point(field_release:vs.TagFractureSectionGetResp.ValueType)
  return valuetype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagFractureSectionGetResp::set_allocated_valuetype(std::string* valuetype) {
  if (valuetype != nullptr) {
    
  } else {
    
  }
  valuetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), valuetype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagFractureSectionGetResp.ValueType)
}

// int32 Start = 4;
inline void TagFractureSectionGetResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFractureSectionGetResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFractureSectionGetResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetResp.Start)
  return _internal_start();
}
inline void TagFractureSectionGetResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagFractureSectionGetResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagFractureSectionGetResp.Start)
}

// int32 End = 5;
inline void TagFractureSectionGetResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFractureSectionGetResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFractureSectionGetResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagFractureSectionGetResp.End)
  return _internal_end();
}
inline void TagFractureSectionGetResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagFractureSectionGetResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagFractureSectionGetResp.End)
}

// -------------------------------------------------------------------

// TagCountByRangeGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagCountByRangeGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagCountByRangeGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagCountByRangeGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagCountByRangeGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagCountByRangeGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.Kvs)
  return _internal_kvs();
}
inline void TagCountByRangeGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagCountByRangeGetReq.Kvs)
}
inline ::vs::KVInfo* TagCountByRangeGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagCountByRangeGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagCountByRangeGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagCountByRangeGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagCountByRangeGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagCountByRangeGetReq.Kvs)
  return _msg;
}
inline void TagCountByRangeGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagCountByRangeGetReq.Kvs)
}

// int32 Start = 2;
inline void TagCountByRangeGetReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.Start)
  return _internal_start();
}
inline void TagCountByRangeGetReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagCountByRangeGetReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.Start)
}

// int32 End = 3;
inline void TagCountByRangeGetReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.End)
  return _internal_end();
}
inline void TagCountByRangeGetReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagCountByRangeGetReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.End)
}

// bytes TagName = 4;
inline void TagCountByRangeGetReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagCountByRangeGetReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagCountByRangeGetReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.TagName)
}
inline std::string* TagCountByRangeGetReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagCountByRangeGetReq.TagName)
  return _s;
}
inline const std::string& TagCountByRangeGetReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagCountByRangeGetReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagCountByRangeGetReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagCountByRangeGetReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagCountByRangeGetReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagCountByRangeGetReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagCountByRangeGetReq.TagName)
}

// int32 Count = 5;
inline void TagCountByRangeGetReq::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::count() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.Count)
  return _internal_count();
}
inline void TagCountByRangeGetReq::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagCountByRangeGetReq::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.Count)
}

// -------------------------------------------------------------------

// TagCountByRangeGetResp

// .vs.ErrInfo Err = 1;
inline bool TagCountByRangeGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagCountByRangeGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagCountByRangeGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagCountByRangeGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagCountByRangeGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetResp.Err)
  return _internal_err();
}
inline void TagCountByRangeGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagCountByRangeGetResp.Err)
}
inline ::vs::ErrInfo* TagCountByRangeGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagCountByRangeGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagCountByRangeGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagCountByRangeGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagCountByRangeGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagCountByRangeGetResp.Err)
  return _msg;
}
inline void TagCountByRangeGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagCountByRangeGetResp.Err)
}

// int32 Count = 2;
inline void TagCountByRangeGetResp::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetResp::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetResp::count() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetResp.Count)
  return _internal_count();
}
inline void TagCountByRangeGetResp::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagCountByRangeGetResp::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetResp.Count)
}

// -------------------------------------------------------------------

// TagListGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagListGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagListGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagListGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagListGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagListGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Kvs)
  return _internal_kvs();
}
inline void TagListGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagListGetReq.Kvs)
}
inline ::vs::KVInfo* TagListGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagListGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagListGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagListGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagListGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetReq.Kvs)
  return _msg;
}
inline void TagListGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetReq.Kvs)
}

// int32 Page = 2;
inline void TagListGetReq::clear_page() {
  page_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::_internal_page() const {
  return page_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::page() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Page)
  return _internal_page();
}
inline void TagListGetReq::_internal_set_page(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  page_ = value;
}
inline void TagListGetReq::set_page(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Page)
}

// int32 Size = 3;
inline void TagListGetReq::clear_size() {
  size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::size() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Size)
  return _internal_size();
}
inline void TagListGetReq::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  size_ = value;
}
inline void TagListGetReq::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Size)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagListGetResp_TagInfoMap

// map<string, bytes> Infos = 1;
inline int TagListGetResp_TagInfoMap::_internal_infos_size() const {
  return infos_.size();
}
inline int TagListGetResp_TagInfoMap::infos_size() const {
  return _internal_infos_size();
}
inline void TagListGetResp_TagInfoMap::clear_infos() {
  infos_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagListGetResp_TagInfoMap::_internal_infos() const {
  return infos_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagListGetResp_TagInfoMap::infos() const {
  // @@protoc_insertion_point(field_map:vs.TagListGetResp.TagInfoMap.Infos)
  return _internal_infos();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagListGetResp_TagInfoMap::_internal_mutable_infos() {
  return infos_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagListGetResp_TagInfoMap::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagListGetResp.TagInfoMap.Infos)
  return _internal_mutable_infos();
}

// -------------------------------------------------------------------

// TagListGetResp

// .vs.ErrInfo Err = 1;
inline bool TagListGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagListGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagListGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagListGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagListGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.Err)
  return _internal_err();
}
inline void TagListGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagListGetResp.Err)
}
inline ::vs::ErrInfo* TagListGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagListGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagListGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagListGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagListGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetResp.Err)
  return _msg;
}
inline void TagListGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetResp.Err)
}

// repeated .vs.TagListGetResp.TagInfoMap Tags = 2;
inline int TagListGetResp::_internal_tags_size() const {
  return tags_.size();
}
inline int TagListGetResp::tags_size() const {
  return _internal_tags_size();
}
inline void TagListGetResp::clear_tags() {
  tags_.Clear();
}
inline ::vs::TagListGetResp_TagInfoMap* TagListGetResp::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagListGetResp.Tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >*
TagListGetResp::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagListGetResp.Tags)
  return &tags_;
}
inline const ::vs::TagListGetResp_TagInfoMap& TagListGetResp::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::vs::TagListGetResp_TagInfoMap& TagListGetResp::tags(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.Tags)
  return _internal_tags(index);
}
inline ::vs::TagListGetResp_TagInfoMap* TagListGetResp::_internal_add_tags() {
  return tags_.Add();
}
inline ::vs::TagListGetResp_TagInfoMap* TagListGetResp::add_tags() {
  ::vs::TagListGetResp_TagInfoMap* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:vs.TagListGetResp.Tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >&
TagListGetResp::tags() const {
  // @@protoc_insertion_point(field_list:vs.TagListGetResp.Tags)
  return tags_;
}

// -------------------------------------------------------------------

// DbPingReq

// .vs.KVInfo Kvs = 1;
inline bool DbPingReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool DbPingReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void DbPingReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& DbPingReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& DbPingReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.DbPingReq.Kvs)
  return _internal_kvs();
}
inline void DbPingReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.DbPingReq.Kvs)
}
inline ::vs::KVInfo* DbPingReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* DbPingReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.DbPingReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* DbPingReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* DbPingReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.DbPingReq.Kvs)
  return _msg;
}
inline void DbPingReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.DbPingReq.Kvs)
}

// -------------------------------------------------------------------

// DbPingResp

// .vs.ErrInfo Err = 1;
inline bool DbPingResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool DbPingResp::has_err() const {
  return _internal_has_err();
}
inline void DbPingResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& DbPingResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& DbPingResp::err() const {
  // @@protoc_insertion_point(field_get:vs.DbPingResp.Err)
  return _internal_err();
}
inline void DbPingResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.DbPingResp.Err)
}
inline ::vs::ErrInfo* DbPingResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* DbPingResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.DbPingResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* DbPingResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* DbPingResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.DbPingResp.Err)
  return _msg;
}
inline void DbPingResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.DbPingResp.Err)
}

// int32 Flag = 2;
inline void DbPingResp::clear_flag() {
  flag_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DbPingResp::_internal_flag() const {
  return flag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DbPingResp::flag() const {
  // @@protoc_insertion_point(field_get:vs.DbPingResp.Flag)
  return _internal_flag();
}
inline void DbPingResp::_internal_set_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  flag_ = value;
}
inline void DbPingResp::set_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:vs.DbPingResp.Flag)
}

// -------------------------------------------------------------------

// VsValue

// double Value = 1;
inline void VsValue::clear_value() {
  value_ = 0;
}
inline double VsValue::_internal_value() const {
  return value_;
}
inline double VsValue::value() const {
  // @@protoc_insertion_point(field_get:vs.VsValue.Value)
  return _internal_value();
}
inline void VsValue::_internal_set_value(double value) {
  
  value_ = value;
}
inline void VsValue::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:vs.VsValue.Value)
}

// int32 Time = 2;
inline void VsValue::clear_time() {
  time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::time() const {
  // @@protoc_insertion_point(field_get:vs.VsValue.Time)
  return _internal_time();
}
inline void VsValue::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  time_ = value;
}
inline void VsValue::set_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:vs.VsValue.Time)
}

// int32 Status = 3;
inline void VsValue::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::status() const {
  // @@protoc_insertion_point(field_get:vs.VsValue.Status)
  return _internal_status();
}
inline void VsValue::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void VsValue::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:vs.VsValue.Status)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagValuesByCountGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagValuesByCountGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagValuesByCountGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagValuesByCountGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagValuesByCountGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagValuesByCountGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Kvs)
  return _internal_kvs();
}
inline void TagValuesByCountGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesByCountGetReq.Kvs)
}
inline ::vs::KVInfo* TagValuesByCountGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagValuesByCountGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagValuesByCountGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagValuesByCountGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetReq.Kvs)
  return _msg;
}
inline void TagValuesByCountGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetReq.Kvs)
}

// .vs.HeadReq Head = 2;
inline bool TagValuesByCountGetReq::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool TagValuesByCountGetReq::has_head() const {
  return _internal_has_head();
}
inline void TagValuesByCountGetReq::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::vs::HeadReq& TagValuesByCountGetReq::_internal_head() const {
  const ::vs::HeadReq* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::HeadReq&>(
      ::vs::_HeadReq_default_instance_);
}
inline const ::vs::HeadReq& TagValuesByCountGetReq::head() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Head)
  return _internal_head();
}
inline void TagValuesByCountGetReq::unsafe_arena_set_allocated_head(
    ::vs::HeadReq* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesByCountGetReq.Head)
}
inline ::vs::HeadReq* TagValuesByCountGetReq::release_head() {
  
  ::vs::HeadReq* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::HeadReq* TagValuesByCountGetReq::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetReq.Head)
  
  ::vs::HeadReq* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::vs::HeadReq* TagValuesByCountGetReq::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::HeadReq>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::vs::HeadReq* TagValuesByCountGetReq::mutable_head() {
  ::vs::HeadReq* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetReq.Head)
  return _msg;
}
inline void TagValuesByCountGetReq::set_allocated_head(::vs::HeadReq* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::HeadReq>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetReq.Head)
}

// int32 Count = 3;
inline void TagValuesByCountGetReq::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::count() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Count)
  return _internal_count();
}
inline void TagValuesByCountGetReq::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagValuesByCountGetReq::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.Count)
}

// map<string, bytes> Meta = 4;
inline int TagValuesByCountGetReq::_internal_meta_size() const {
  return meta_.size();
}
inline int TagValuesByCountGetReq::meta_size() const {
  return _internal_meta_size();
}
inline void TagValuesByCountGetReq::clear_meta() {
  meta_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesByCountGetReq::_internal_meta() const {
  return meta_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesByCountGetReq::meta() const {
  // @@protoc_insertion_point(field_map:vs.TagValuesByCountGetReq.Meta)
  return _internal_meta();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesByCountGetReq::_internal_mutable_meta() {
  return meta_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesByCountGetReq::mutable_meta() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagValuesByCountGetReq.Meta)
  return _internal_mutable_meta();
}

// -------------------------------------------------------------------

// TagValuesByCountGetResp

// .vs.ErrInfo Err = 1;
inline bool TagValuesByCountGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagValuesByCountGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagValuesByCountGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagValuesByCountGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagValuesByCountGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.Err)
  return _internal_err();
}
inline void TagValuesByCountGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesByCountGetResp.Err)
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetResp.Err)
  return _msg;
}
inline void TagValuesByCountGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetResp.Err)
}

// repeated .vs.VsValueMap Values = 2;
inline int TagValuesByCountGetResp::_internal_values_size() const {
  return values_.size();
}
inline int TagValuesByCountGetResp::values_size() const {
  return _internal_values_size();
}
inline void TagValuesByCountGetResp::clear_values() {
  values_.Clear();
}
inline ::vs::VsValueMap* TagValuesByCountGetResp::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetResp.Values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
TagValuesByCountGetResp::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagValuesByCountGetResp.Values)
  return &values_;
}
inline const ::vs::VsValueMap& TagValuesByCountGetResp::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::vs::VsValueMap& TagValuesByCountGetResp::values(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.Values)
  return _internal_values(index);
}
inline ::vs::VsValueMap* TagValuesByCountGetResp::_internal_add_values() {
  return values_.Add();
}
inline ::vs::VsValueMap* TagValuesByCountGetResp::add_values() {
  ::vs::VsValueMap* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:vs.TagValuesByCountGetResp.Values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
TagValuesByCountGetResp::values() const {
  // @@protoc_insertion_point(field_list:vs.TagValuesByCountGetResp.Values)
  return values_;
}

// string ValueType = 3;
inline void TagValuesByCountGetResp::clear_valuetype() {
  valuetype_.ClearToEmpty();
}
inline const std::string& TagValuesByCountGetResp::valuetype() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.ValueType)
  return _internal_valuetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesByCountGetResp::set_valuetype(ArgT0&& arg0, ArgT... args) {
 
 valuetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.ValueType)
}
inline std::string* TagValuesByCountGetResp::mutable_valuetype() {
  std::string* _s = _internal_mutable_valuetype();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetResp.ValueType)
  return _s;
}
inline const std::string& TagValuesByCountGetResp::_internal_valuetype() const {
  return valuetype_.Get();
}
inline void TagValuesByCountGetResp::_internal_set_valuetype(const std::string& value) {
  
  valuetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetResp::_internal_mutable_valuetype() {
  
  return valuetype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetResp::release_valuetype() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetResp.ValueType)
  return valuetype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesByCountGetResp::set_allocated_valuetype(std::string* valuetype) {
  if (valuetype != nullptr) {
    
  } else {
    
  }
  valuetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), valuetype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetResp.ValueType)
}

// int32 Start = 4;
inline void TagValuesByCountGetResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.Start)
  return _internal_start();
}
inline void TagValuesByCountGetResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagValuesByCountGetResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.Start)
}

// int32 End = 5;
inline void TagValuesByCountGetResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.End)
  return _internal_end();
}
inline void TagValuesByCountGetResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagValuesByCountGetResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.End)
}

// bool IsLast = 6;
inline void TagValuesByCountGetResp::clear_islast() {
  islast_ = false;
}
inline bool TagValuesByCountGetResp::_internal_islast() const {
  return islast_;
}
inline bool TagValuesByCountGetResp::islast() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.IsLast)
  return _internal_islast();
}
inline void TagValuesByCountGetResp::_internal_set_islast(bool value) {
  
  islast_ = value;
}
inline void TagValuesByCountGetResp::set_islast(bool value) {
  _internal_set_islast(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.IsLast)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagValuesGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagValuesGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagValuesGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagValuesGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagValuesGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagValuesGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Kvs)
  return _internal_kvs();
}
inline void TagValuesGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesGetReq.Kvs)
}
inline ::vs::KVInfo* TagValuesGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagValuesGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagValuesGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagValuesGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetReq.Kvs)
  return _msg;
}
inline void TagValuesGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetReq.Kvs)
}

// .vs.HeadReq Head = 2;
inline bool TagValuesGetReq::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool TagValuesGetReq::has_head() const {
  return _internal_has_head();
}
inline void TagValuesGetReq::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::vs::HeadReq& TagValuesGetReq::_internal_head() const {
  const ::vs::HeadReq* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::HeadReq&>(
      ::vs::_HeadReq_default_instance_);
}
inline const ::vs::HeadReq& TagValuesGetReq::head() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Head)
  return _internal_head();
}
inline void TagValuesGetReq::unsafe_arena_set_allocated_head(
    ::vs::HeadReq* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesGetReq.Head)
}
inline ::vs::HeadReq* TagValuesGetReq::release_head() {
  
  ::vs::HeadReq* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::HeadReq* TagValuesGetReq::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetReq.Head)
  
  ::vs::HeadReq* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::vs::HeadReq* TagValuesGetReq::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::HeadReq>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::vs::HeadReq* TagValuesGetReq::mutable_head() {
  ::vs::HeadReq* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetReq.Head)
  return _msg;
}
inline void TagValuesGetReq::set_allocated_head(::vs::HeadReq* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::HeadReq>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetReq.Head)
}

// map<string, bytes> Extend = 3;
inline int TagValuesGetReq::_internal_extend_size() const {
  return extend_.size();
}
inline int TagValuesGetReq::extend_size() const {
  return _internal_extend_size();
}
inline void TagValuesGetReq::clear_extend() {
  extend_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesGetReq::_internal_extend() const {
  return extend_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesGetReq::extend() const {
  // @@protoc_insertion_point(field_map:vs.TagValuesGetReq.Extend)
  return _internal_extend();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesGetReq::_internal_mutable_extend() {
  return extend_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesGetReq::mutable_extend() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagValuesGetReq.Extend)
  return _internal_mutable_extend();
}

// -------------------------------------------------------------------

// TagValuesGetResp

// .vs.ErrInfo Err = 1;
inline bool TagValuesGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagValuesGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagValuesGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagValuesGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagValuesGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.Err)
  return _internal_err();
}
inline void TagValuesGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesGetResp.Err)
}
inline ::vs::ErrInfo* TagValuesGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagValuesGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagValuesGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagValuesGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetResp.Err)
  return _msg;
}
inline void TagValuesGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetResp.Err)
}

// repeated .vs.VsValueMap Values = 2;
inline int TagValuesGetResp::_internal_values_size() const {
  return values_.size();
}
inline int TagValuesGetResp::values_size() const {
  return _internal_values_size();
}
inline void TagValuesGetResp::clear_values() {
  values_.Clear();
}
inline ::vs::VsValueMap* TagValuesGetResp::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetResp.Values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
TagValuesGetResp::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagValuesGetResp.Values)
  return &values_;
}
inline const ::vs::VsValueMap& TagValuesGetResp::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::vs::VsValueMap& TagValuesGetResp::values(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.Values)
  return _internal_values(index);
}
inline ::vs::VsValueMap* TagValuesGetResp::_internal_add_values() {
  return values_.Add();
}
inline ::vs::VsValueMap* TagValuesGetResp::add_values() {
  ::vs::VsValueMap* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:vs.TagValuesGetResp.Values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
TagValuesGetResp::values() const {
  // @@protoc_insertion_point(field_list:vs.TagValuesGetResp.Values)
  return values_;
}

// int32 Start = 3;
inline void TagValuesGetResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.Start)
  return _internal_start();
}
inline void TagValuesGetResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagValuesGetResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetResp.Start)
}

// int32 End = 4;
inline void TagValuesGetResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.End)
  return _internal_end();
}
inline void TagValuesGetResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagValuesGetResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetResp.End)
}

// -------------------------------------------------------------------

// TagFeatureGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagFeatureGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagFeatureGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagFeatureGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagFeatureGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagFeatureGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Kvs)
  return _internal_kvs();
}
inline void TagFeatureGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagFeatureGetReq.Kvs)
}
inline ::vs::KVInfo* TagFeatureGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagFeatureGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagFeatureGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagFeatureGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetReq.Kvs)
  return _msg;
}
inline void TagFeatureGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetReq.Kvs)
}

// int64 Start = 2;
inline void TagFeatureGetReq::clear_start() {
  start_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Start)
  return _internal_start();
}
inline void TagFeatureGetReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_ = value;
}
inline void TagFeatureGetReq::set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Start)
}

// int64 End = 3;
inline void TagFeatureGetReq::clear_end() {
  end_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.End)
  return _internal_end();
}
inline void TagFeatureGetReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_ = value;
}
inline void TagFeatureGetReq::set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.End)
}

// bytes TagName = 4;
inline void TagFeatureGetReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagFeatureGetReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagFeatureGetReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.TagName)
}
inline std::string* TagFeatureGetReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetReq.TagName)
  return _s;
}
inline const std::string& TagFeatureGetReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagFeatureGetReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagFeatureGetReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetReq.TagName)
}

// repeated int32 Verifies = 5;
inline int TagFeatureGetReq::_internal_verifies_size() const {
  return verifies_.size();
}
inline int TagFeatureGetReq::verifies_size() const {
  return _internal_verifies_size();
}
inline void TagFeatureGetReq::clear_verifies() {
  verifies_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::_internal_verifies(int index) const {
  return verifies_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::verifies(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Verifies)
  return _internal_verifies(index);
}
inline void TagFeatureGetReq::set_verifies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  verifies_.Set(index, value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Verifies)
}
inline void TagFeatureGetReq::_internal_add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  verifies_.Add(value);
}
inline void TagFeatureGetReq::add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_verifies(value);
  // @@protoc_insertion_point(field_add:vs.TagFeatureGetReq.Verifies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TagFeatureGetReq::_internal_verifies() const {
  return verifies_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TagFeatureGetReq::verifies() const {
  // @@protoc_insertion_point(field_list:vs.TagFeatureGetReq.Verifies)
  return _internal_verifies();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TagFeatureGetReq::_internal_mutable_verifies() {
  return &verifies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TagFeatureGetReq::mutable_verifies() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagFeatureGetReq.Verifies)
  return _internal_mutable_verifies();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagFeatureGetResp

// .vs.ErrInfo Err = 1;
inline bool TagFeatureGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagFeatureGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagFeatureGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagFeatureGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagFeatureGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetResp.Err)
  return _internal_err();
}
inline void TagFeatureGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagFeatureGetResp.Err)
}
inline ::vs::ErrInfo* TagFeatureGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagFeatureGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagFeatureGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagFeatureGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetResp.Err)
  return _msg;
}
inline void TagFeatureGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetResp.Err)
}

// map<string, .vs.VsValue> Feats = 2;
inline int TagFeatureGetResp::_internal_feats_size() const {
  return feats_.size();
}
inline int TagFeatureGetResp::feats_size() const {
  return _internal_feats_size();
}
inline void TagFeatureGetResp::clear_feats() {
  feats_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
TagFeatureGetResp::_internal_feats() const {
  return feats_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
TagFeatureGetResp::feats() const {
  // @@protoc_insertion_point(field_map:vs.TagFeatureGetResp.Feats)
  return _internal_feats();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
TagFeatureGetResp::_internal_mutable_feats() {
  return feats_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
TagFeatureGetResp::mutable_feats() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagFeatureGetResp.Feats)
  return _internal_mutable_feats();
}

// int32 Start = 3;
inline void TagFeatureGetResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetResp.Start)
  return _internal_start();
}
inline void TagFeatureGetResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagFeatureGetResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetResp.Start)
}

// int32 End = 4;
inline void TagFeatureGetResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetResp.End)
  return _internal_end();
}
inline void TagFeatureGetResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagFeatureGetResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetResp.End)
}

// -------------------------------------------------------------------

// TagDescGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagDescGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagDescGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagDescGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagDescGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagDescGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagDescGetReq.Kvs)
  return _internal_kvs();
}
inline void TagDescGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagDescGetReq.Kvs)
}
inline ::vs::KVInfo* TagDescGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagDescGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagDescGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagDescGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagDescGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagDescGetReq.Kvs)
  return _msg;
}
inline void TagDescGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagDescGetReq.Kvs)
}

// bytes TagName = 2;
inline void TagDescGetReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagDescGetReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagDescGetReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDescGetReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagDescGetReq.TagName)
}
inline std::string* TagDescGetReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagDescGetReq.TagName)
  return _s;
}
inline const std::string& TagDescGetReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagDescGetReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagDescGetReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagDescGetReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagDescGetReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagDescGetReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagDescGetReq.TagName)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagDescGetResp

// bytes TagName = 1;
inline void TagDescGetResp::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagDescGetResp::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagDescGetResp.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDescGetResp::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagDescGetResp.TagName)
}
inline std::string* TagDescGetResp::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagDescGetResp.TagName)
  return _s;
}
inline const std::string& TagDescGetResp::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagDescGetResp::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagDescGetResp::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagDescGetResp::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagDescGetResp.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagDescGetResp::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagDescGetResp.TagName)
}

// map<string, bytes> Desc = 2;
inline int TagDescGetResp::_internal_desc_size() const {
  return desc_.size();
}
inline int TagDescGetResp::desc_size() const {
  return _internal_desc_size();
}
inline void TagDescGetResp::clear_desc() {
  desc_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagDescGetResp::_internal_desc() const {
  return desc_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagDescGetResp::desc() const {
  // @@protoc_insertion_point(field_map:vs.TagDescGetResp.Desc)
  return _internal_desc();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagDescGetResp::_internal_mutable_desc() {
  return desc_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagDescGetResp::mutable_desc() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagDescGetResp.Desc)
  return _internal_mutable_desc();
}

// -------------------------------------------------------------------

// TagTimeSectionReq

// .vs.KVInfo Kvs = 1;
inline bool TagTimeSectionReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagTimeSectionReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagTimeSectionReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagTimeSectionReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagTimeSectionReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.Kvs)
  return _internal_kvs();
}
inline void TagTimeSectionReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagTimeSectionReq.Kvs)
}
inline ::vs::KVInfo* TagTimeSectionReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagTimeSectionReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagTimeSectionReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagTimeSectionReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionReq.Kvs)
  return _msg;
}
inline void TagTimeSectionReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionReq.Kvs)
}

// bytes TagName = 2;
inline void TagTimeSectionReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagTimeSectionReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagTimeSectionReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.TagName)
}
inline std::string* TagTimeSectionReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionReq.TagName)
  return _s;
}
inline const std::string& TagTimeSectionReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagTimeSectionReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagTimeSectionReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionReq.TagName)
}

// int32 Start = 3;
inline void TagTimeSectionReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.Start)
  return _internal_start();
}
inline void TagTimeSectionReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagTimeSectionReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.Start)
}

// int32 End = 4;
inline void TagTimeSectionReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.End)
  return _internal_end();
}
inline void TagTimeSectionReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagTimeSectionReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.End)
}

// -------------------------------------------------------------------

// TagTimeSectionResp

// .vs.ErrInfo Err = 1;
inline bool TagTimeSectionResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagTimeSectionResp::has_err() const {
  return _internal_has_err();
}
inline void TagTimeSectionResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagTimeSectionResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagTimeSectionResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionResp.Err)
  return _internal_err();
}
inline void TagTimeSectionResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagTimeSectionResp.Err)
}
inline ::vs::ErrInfo* TagTimeSectionResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagTimeSectionResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagTimeSectionResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagTimeSectionResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionResp.Err)
  return _msg;
}
inline void TagTimeSectionResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionResp.Err)
}

// int32 Start = 2;
inline void TagTimeSectionResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionResp.Start)
  return _internal_start();
}
inline void TagTimeSectionResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagTimeSectionResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionResp.Start)
}

// int32 End = 3;
inline void TagTimeSectionResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionResp.End)
  return _internal_end();
}
inline void TagTimeSectionResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagTimeSectionResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionResp.End)
}

// -------------------------------------------------------------------

// ServiceStopReq

// -------------------------------------------------------------------

// ServiceStopResp

// -------------------------------------------------------------------

// ReleaseConnectReq

// -------------------------------------------------------------------

// ReleaseConnectResp

// -------------------------------------------------------------------

// TagSnapshotValueReq

// .vs.KVInfo Kvs = 1;
inline bool TagSnapshotValueReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagSnapshotValueReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagSnapshotValueReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagSnapshotValueReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagSnapshotValueReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagSnapshotValueReq.Kvs)
  return _internal_kvs();
}
inline void TagSnapshotValueReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagSnapshotValueReq.Kvs)
}
inline ::vs::KVInfo* TagSnapshotValueReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagSnapshotValueReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagSnapshotValueReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagSnapshotValueReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagSnapshotValueReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagSnapshotValueReq.Kvs)
  return _msg;
}
inline void TagSnapshotValueReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagSnapshotValueReq.Kvs)
}

// bytes TagName = 2;
inline void TagSnapshotValueReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagSnapshotValueReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagSnapshotValueReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagSnapshotValueReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagSnapshotValueReq.TagName)
}
inline std::string* TagSnapshotValueReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagSnapshotValueReq.TagName)
  return _s;
}
inline const std::string& TagSnapshotValueReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagSnapshotValueReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagSnapshotValueReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagSnapshotValueReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagSnapshotValueReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagSnapshotValueReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagSnapshotValueReq.TagName)
}

// int32 Start = 3;
inline void TagSnapshotValueReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagSnapshotValueReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagSnapshotValueReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagSnapshotValueReq.Start)
  return _internal_start();
}
inline void TagSnapshotValueReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagSnapshotValueReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagSnapshotValueReq.Start)
}

// int32 End = 4;
inline void TagSnapshotValueReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagSnapshotValueReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagSnapshotValueReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagSnapshotValueReq.End)
  return _internal_end();
}
inline void TagSnapshotValueReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagSnapshotValueReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagSnapshotValueReq.End)
}

// -------------------------------------------------------------------

// TagSnapshotValueResp

// .vs.ErrInfo Err = 1;
inline bool TagSnapshotValueResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagSnapshotValueResp::has_err() const {
  return _internal_has_err();
}
inline void TagSnapshotValueResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagSnapshotValueResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagSnapshotValueResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagSnapshotValueResp.Err)
  return _internal_err();
}
inline void TagSnapshotValueResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagSnapshotValueResp.Err)
}
inline ::vs::ErrInfo* TagSnapshotValueResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagSnapshotValueResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagSnapshotValueResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagSnapshotValueResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagSnapshotValueResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagSnapshotValueResp.Err)
  return _msg;
}
inline void TagSnapshotValueResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagSnapshotValueResp.Err)
}

// .vs.VsValueMap Values = 2;
inline bool TagSnapshotValueResp::_internal_has_values() const {
  return this != internal_default_instance() && values_ != nullptr;
}
inline bool TagSnapshotValueResp::has_values() const {
  return _internal_has_values();
}
inline void TagSnapshotValueResp::clear_values() {
  if (GetArenaForAllocation() == nullptr && values_ != nullptr) {
    delete values_;
  }
  values_ = nullptr;
}
inline const ::vs::VsValueMap& TagSnapshotValueResp::_internal_values() const {
  const ::vs::VsValueMap* p = values_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::VsValueMap&>(
      ::vs::_VsValueMap_default_instance_);
}
inline const ::vs::VsValueMap& TagSnapshotValueResp::values() const {
  // @@protoc_insertion_point(field_get:vs.TagSnapshotValueResp.Values)
  return _internal_values();
}
inline void TagSnapshotValueResp::unsafe_arena_set_allocated_values(
    ::vs::VsValueMap* values) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(values_);
  }
  values_ = values;
  if (values) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagSnapshotValueResp.Values)
}
inline ::vs::VsValueMap* TagSnapshotValueResp::release_values() {
  
  ::vs::VsValueMap* temp = values_;
  values_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::VsValueMap* TagSnapshotValueResp::unsafe_arena_release_values() {
  // @@protoc_insertion_point(field_release:vs.TagSnapshotValueResp.Values)
  
  ::vs::VsValueMap* temp = values_;
  values_ = nullptr;
  return temp;
}
inline ::vs::VsValueMap* TagSnapshotValueResp::_internal_mutable_values() {
  
  if (values_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::VsValueMap>(GetArenaForAllocation());
    values_ = p;
  }
  return values_;
}
inline ::vs::VsValueMap* TagSnapshotValueResp::mutable_values() {
  ::vs::VsValueMap* _msg = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:vs.TagSnapshotValueResp.Values)
  return _msg;
}
inline void TagSnapshotValueResp::set_allocated_values(::vs::VsValueMap* values) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete values_;
  }
  if (values) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::VsValueMap>::GetOwningArena(values);
    if (message_arena != submessage_arena) {
      values = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, values, submessage_arena);
    }
    
  } else {
    
  }
  values_ = values;
  // @@protoc_insertion_point(field_set_allocated:vs.TagSnapshotValueResp.Values)
}

// -------------------------------------------------------------------

// InsertData

// int32 Type = 1;
inline void InsertData::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertData::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertData::type() const {
  // @@protoc_insertion_point(field_get:vs.InsertData.Type)
  return _internal_type();
}
inline void InsertData::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void InsertData::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vs.InsertData.Type)
}

// int32 Status = 2;
inline void InsertData::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertData::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertData::status() const {
  // @@protoc_insertion_point(field_get:vs.InsertData.Status)
  return _internal_status();
}
inline void InsertData::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void InsertData::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:vs.InsertData.Status)
}

// double Value = 3;
inline void InsertData::clear_value() {
  value_ = 0;
}
inline double InsertData::_internal_value() const {
  return value_;
}
inline double InsertData::value() const {
  // @@protoc_insertion_point(field_get:vs.InsertData.Value)
  return _internal_value();
}
inline void InsertData::_internal_set_value(double value) {
  
  value_ = value;
}
inline void InsertData::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:vs.InsertData.Value)
}

// int32 Time = 4;
inline void InsertData::clear_time() {
  time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertData::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertData::time() const {
  // @@protoc_insertion_point(field_get:vs.InsertData.Time)
  return _internal_time();
}
inline void InsertData::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  time_ = value;
}
inline void InsertData::set_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:vs.InsertData.Time)
}

// bytes TagName = 5;
inline void InsertData::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& InsertData::tagname() const {
  // @@protoc_insertion_point(field_get:vs.InsertData.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertData::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.InsertData.TagName)
}
inline std::string* InsertData::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.InsertData.TagName)
  return _s;
}
inline const std::string& InsertData::_internal_tagname() const {
  return tagname_.Get();
}
inline void InsertData::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertData::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertData::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.InsertData.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertData::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.InsertData.TagName)
}

// -------------------------------------------------------------------

// TagAppendRTTagDataByBatchReq

// .vs.KVInfo Kvs = 1;
inline bool TagAppendRTTagDataByBatchReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagAppendRTTagDataByBatchReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagAppendRTTagDataByBatchReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagAppendRTTagDataByBatchReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagAppendRTTagDataByBatchReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagAppendRTTagDataByBatchReq.Kvs)
  return _internal_kvs();
}
inline void TagAppendRTTagDataByBatchReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagAppendRTTagDataByBatchReq.Kvs)
}
inline ::vs::KVInfo* TagAppendRTTagDataByBatchReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagAppendRTTagDataByBatchReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagAppendRTTagDataByBatchReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagAppendRTTagDataByBatchReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagAppendRTTagDataByBatchReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagAppendRTTagDataByBatchReq.Kvs)
  return _msg;
}
inline void TagAppendRTTagDataByBatchReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagAppendRTTagDataByBatchReq.Kvs)
}

// repeated .vs.InsertData Data = 2;
inline int TagAppendRTTagDataByBatchReq::_internal_data_size() const {
  return data_.size();
}
inline int TagAppendRTTagDataByBatchReq::data_size() const {
  return _internal_data_size();
}
inline void TagAppendRTTagDataByBatchReq::clear_data() {
  data_.Clear();
}
inline ::vs::InsertData* TagAppendRTTagDataByBatchReq::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagAppendRTTagDataByBatchReq.Data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >*
TagAppendRTTagDataByBatchReq::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagAppendRTTagDataByBatchReq.Data)
  return &data_;
}
inline const ::vs::InsertData& TagAppendRTTagDataByBatchReq::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::vs::InsertData& TagAppendRTTagDataByBatchReq::data(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagAppendRTTagDataByBatchReq.Data)
  return _internal_data(index);
}
inline ::vs::InsertData* TagAppendRTTagDataByBatchReq::_internal_add_data() {
  return data_.Add();
}
inline ::vs::InsertData* TagAppendRTTagDataByBatchReq::add_data() {
  ::vs::InsertData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:vs.TagAppendRTTagDataByBatchReq.Data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >&
TagAppendRTTagDataByBatchReq::data() const {
  // @@protoc_insertion_point(field_list:vs.TagAppendRTTagDataByBatchReq.Data)
  return data_;
}

// -------------------------------------------------------------------

// TagAppendRTTagDataByBatchResp

// .vs.ErrInfo Err = 1;
inline bool TagAppendRTTagDataByBatchResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagAppendRTTagDataByBatchResp::has_err() const {
  return _internal_has_err();
}
inline void TagAppendRTTagDataByBatchResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagAppendRTTagDataByBatchResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagAppendRTTagDataByBatchResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagAppendRTTagDataByBatchResp.Err)
  return _internal_err();
}
inline void TagAppendRTTagDataByBatchResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagAppendRTTagDataByBatchResp.Err)
}
inline ::vs::ErrInfo* TagAppendRTTagDataByBatchResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagAppendRTTagDataByBatchResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagAppendRTTagDataByBatchResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagAppendRTTagDataByBatchResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagAppendRTTagDataByBatchResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagAppendRTTagDataByBatchResp.Err)
  return _msg;
}
inline void TagAppendRTTagDataByBatchResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagAppendRTTagDataByBatchResp.Err)
}

// repeated .vs.InsertData Data = 2;
inline int TagAppendRTTagDataByBatchResp::_internal_data_size() const {
  return data_.size();
}
inline int TagAppendRTTagDataByBatchResp::data_size() const {
  return _internal_data_size();
}
inline void TagAppendRTTagDataByBatchResp::clear_data() {
  data_.Clear();
}
inline ::vs::InsertData* TagAppendRTTagDataByBatchResp::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagAppendRTTagDataByBatchResp.Data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >*
TagAppendRTTagDataByBatchResp::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagAppendRTTagDataByBatchResp.Data)
  return &data_;
}
inline const ::vs::InsertData& TagAppendRTTagDataByBatchResp::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::vs::InsertData& TagAppendRTTagDataByBatchResp::data(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagAppendRTTagDataByBatchResp.Data)
  return _internal_data(index);
}
inline ::vs::InsertData* TagAppendRTTagDataByBatchResp::_internal_add_data() {
  return data_.Add();
}
inline ::vs::InsertData* TagAppendRTTagDataByBatchResp::add_data() {
  ::vs::InsertData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:vs.TagAppendRTTagDataByBatchResp.Data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::InsertData >&
TagAppendRTTagDataByBatchResp::data() const {
  // @@protoc_insertion_point(field_list:vs.TagAppendRTTagDataByBatchResp.Data)
  return data_;
}

// -------------------------------------------------------------------

// GetRTDataByBatchReq

// .vs.KVInfo Kvs = 1;
inline bool GetRTDataByBatchReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool GetRTDataByBatchReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void GetRTDataByBatchReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& GetRTDataByBatchReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& GetRTDataByBatchReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.GetRTDataByBatchReq.Kvs)
  return _internal_kvs();
}
inline void GetRTDataByBatchReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.GetRTDataByBatchReq.Kvs)
}
inline ::vs::KVInfo* GetRTDataByBatchReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* GetRTDataByBatchReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.GetRTDataByBatchReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* GetRTDataByBatchReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* GetRTDataByBatchReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.GetRTDataByBatchReq.Kvs)
  return _msg;
}
inline void GetRTDataByBatchReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.GetRTDataByBatchReq.Kvs)
}

// repeated bytes TagNames = 2;
inline int GetRTDataByBatchReq::_internal_tagnames_size() const {
  return tagnames_.size();
}
inline int GetRTDataByBatchReq::tagnames_size() const {
  return _internal_tagnames_size();
}
inline void GetRTDataByBatchReq::clear_tagnames() {
  tagnames_.Clear();
}
inline std::string* GetRTDataByBatchReq::add_tagnames() {
  std::string* _s = _internal_add_tagnames();
  // @@protoc_insertion_point(field_add_mutable:vs.GetRTDataByBatchReq.TagNames)
  return _s;
}
inline const std::string& GetRTDataByBatchReq::_internal_tagnames(int index) const {
  return tagnames_.Get(index);
}
inline const std::string& GetRTDataByBatchReq::tagnames(int index) const {
  // @@protoc_insertion_point(field_get:vs.GetRTDataByBatchReq.TagNames)
  return _internal_tagnames(index);
}
inline std::string* GetRTDataByBatchReq::mutable_tagnames(int index) {
  // @@protoc_insertion_point(field_mutable:vs.GetRTDataByBatchReq.TagNames)
  return tagnames_.Mutable(index);
}
inline void GetRTDataByBatchReq::set_tagnames(int index, const std::string& value) {
  tagnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:vs.GetRTDataByBatchReq.TagNames)
}
inline void GetRTDataByBatchReq::set_tagnames(int index, std::string&& value) {
  tagnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:vs.GetRTDataByBatchReq.TagNames)
}
inline void GetRTDataByBatchReq::set_tagnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tagnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vs.GetRTDataByBatchReq.TagNames)
}
inline void GetRTDataByBatchReq::set_tagnames(int index, const void* value, size_t size) {
  tagnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vs.GetRTDataByBatchReq.TagNames)
}
inline std::string* GetRTDataByBatchReq::_internal_add_tagnames() {
  return tagnames_.Add();
}
inline void GetRTDataByBatchReq::add_tagnames(const std::string& value) {
  tagnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vs.GetRTDataByBatchReq.TagNames)
}
inline void GetRTDataByBatchReq::add_tagnames(std::string&& value) {
  tagnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vs.GetRTDataByBatchReq.TagNames)
}
inline void GetRTDataByBatchReq::add_tagnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tagnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vs.GetRTDataByBatchReq.TagNames)
}
inline void GetRTDataByBatchReq::add_tagnames(const void* value, size_t size) {
  tagnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vs.GetRTDataByBatchReq.TagNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetRTDataByBatchReq::tagnames() const {
  // @@protoc_insertion_point(field_list:vs.GetRTDataByBatchReq.TagNames)
  return tagnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetRTDataByBatchReq::mutable_tagnames() {
  // @@protoc_insertion_point(field_mutable_list:vs.GetRTDataByBatchReq.TagNames)
  return &tagnames_;
}

// -------------------------------------------------------------------

// GetRTDataByBatchResp

// .vs.ErrInfo Err = 1;
inline bool GetRTDataByBatchResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool GetRTDataByBatchResp::has_err() const {
  return _internal_has_err();
}
inline void GetRTDataByBatchResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& GetRTDataByBatchResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& GetRTDataByBatchResp::err() const {
  // @@protoc_insertion_point(field_get:vs.GetRTDataByBatchResp.Err)
  return _internal_err();
}
inline void GetRTDataByBatchResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.GetRTDataByBatchResp.Err)
}
inline ::vs::ErrInfo* GetRTDataByBatchResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* GetRTDataByBatchResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.GetRTDataByBatchResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* GetRTDataByBatchResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* GetRTDataByBatchResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.GetRTDataByBatchResp.Err)
  return _msg;
}
inline void GetRTDataByBatchResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.GetRTDataByBatchResp.Err)
}

// repeated .vs.VsValueMap Values = 2;
inline int GetRTDataByBatchResp::_internal_values_size() const {
  return values_.size();
}
inline int GetRTDataByBatchResp::values_size() const {
  return _internal_values_size();
}
inline void GetRTDataByBatchResp::clear_values() {
  values_.Clear();
}
inline ::vs::VsValueMap* GetRTDataByBatchResp::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:vs.GetRTDataByBatchResp.Values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >*
GetRTDataByBatchResp::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:vs.GetRTDataByBatchResp.Values)
  return &values_;
}
inline const ::vs::VsValueMap& GetRTDataByBatchResp::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::vs::VsValueMap& GetRTDataByBatchResp::values(int index) const {
  // @@protoc_insertion_point(field_get:vs.GetRTDataByBatchResp.Values)
  return _internal_values(index);
}
inline ::vs::VsValueMap* GetRTDataByBatchResp::_internal_add_values() {
  return values_.Add();
}
inline ::vs::VsValueMap* GetRTDataByBatchResp::add_values() {
  ::vs::VsValueMap* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:vs.GetRTDataByBatchResp.Values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::VsValueMap >&
GetRTDataByBatchResp::values() const {
  // @@protoc_insertion_point(field_list:vs.GetRTDataByBatchResp.Values)
  return values_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vs

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vs_2eproto
