// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vs_2eproto;
namespace vs {
class ConfigFileSetReq;
struct ConfigFileSetReqDefaultTypeInternal;
extern ConfigFileSetReqDefaultTypeInternal _ConfigFileSetReq_default_instance_;
class ConfigFileSetResp;
struct ConfigFileSetRespDefaultTypeInternal;
extern ConfigFileSetRespDefaultTypeInternal _ConfigFileSetResp_default_instance_;
class DbPingReq;
struct DbPingReqDefaultTypeInternal;
extern DbPingReqDefaultTypeInternal _DbPingReq_default_instance_;
class DbPingResp;
struct DbPingRespDefaultTypeInternal;
extern DbPingRespDefaultTypeInternal _DbPingResp_default_instance_;
class ErrInfo;
struct ErrInfoDefaultTypeInternal;
extern ErrInfoDefaultTypeInternal _ErrInfo_default_instance_;
class KVInfo;
struct KVInfoDefaultTypeInternal;
extern KVInfoDefaultTypeInternal _KVInfo_default_instance_;
class KVInfo_KvsEntry_DoNotUse;
struct KVInfo_KvsEntry_DoNotUseDefaultTypeInternal;
extern KVInfo_KvsEntry_DoNotUseDefaultTypeInternal _KVInfo_KvsEntry_DoNotUse_default_instance_;
class TagCountByRangeGetReq;
struct TagCountByRangeGetReqDefaultTypeInternal;
extern TagCountByRangeGetReqDefaultTypeInternal _TagCountByRangeGetReq_default_instance_;
class TagCountByRangeGetResp;
struct TagCountByRangeGetRespDefaultTypeInternal;
extern TagCountByRangeGetRespDefaultTypeInternal _TagCountByRangeGetResp_default_instance_;
class TagDescGetReq;
struct TagDescGetReqDefaultTypeInternal;
extern TagDescGetReqDefaultTypeInternal _TagDescGetReq_default_instance_;
class TagDescGetResp;
struct TagDescGetRespDefaultTypeInternal;
extern TagDescGetRespDefaultTypeInternal _TagDescGetResp_default_instance_;
class TagDescGetResp_DescEntry_DoNotUse;
struct TagDescGetResp_DescEntry_DoNotUseDefaultTypeInternal;
extern TagDescGetResp_DescEntry_DoNotUseDefaultTypeInternal _TagDescGetResp_DescEntry_DoNotUse_default_instance_;
class TagFeatureGetReq;
struct TagFeatureGetReqDefaultTypeInternal;
extern TagFeatureGetReqDefaultTypeInternal _TagFeatureGetReq_default_instance_;
class TagFeatureGetResp;
struct TagFeatureGetRespDefaultTypeInternal;
extern TagFeatureGetRespDefaultTypeInternal _TagFeatureGetResp_default_instance_;
class TagFeatureGetResp_FeatEntry_DoNotUse;
struct TagFeatureGetResp_FeatEntry_DoNotUseDefaultTypeInternal;
extern TagFeatureGetResp_FeatEntry_DoNotUseDefaultTypeInternal _TagFeatureGetResp_FeatEntry_DoNotUse_default_instance_;
class TagListGetReq;
struct TagListGetReqDefaultTypeInternal;
extern TagListGetReqDefaultTypeInternal _TagListGetReq_default_instance_;
class TagListGetResp;
struct TagListGetRespDefaultTypeInternal;
extern TagListGetRespDefaultTypeInternal _TagListGetResp_default_instance_;
class TagListGetResp_Filed;
struct TagListGetResp_FiledDefaultTypeInternal;
extern TagListGetResp_FiledDefaultTypeInternal _TagListGetResp_Filed_default_instance_;
class TagListGetResp_TagInfoMap;
struct TagListGetResp_TagInfoMapDefaultTypeInternal;
extern TagListGetResp_TagInfoMapDefaultTypeInternal _TagListGetResp_TagInfoMap_default_instance_;
class TagListGetResp_TagInfoMap_InfoEntry_DoNotUse;
struct TagListGetResp_TagInfoMap_InfoEntry_DoNotUseDefaultTypeInternal;
extern TagListGetResp_TagInfoMap_InfoEntry_DoNotUseDefaultTypeInternal _TagListGetResp_TagInfoMap_InfoEntry_DoNotUse_default_instance_;
class TagTimeSectionReq;
struct TagTimeSectionReqDefaultTypeInternal;
extern TagTimeSectionReqDefaultTypeInternal _TagTimeSectionReq_default_instance_;
class TagTimeSectionResp;
struct TagTimeSectionRespDefaultTypeInternal;
extern TagTimeSectionRespDefaultTypeInternal _TagTimeSectionResp_default_instance_;
class TagValuesByCountGetReq;
struct TagValuesByCountGetReqDefaultTypeInternal;
extern TagValuesByCountGetReqDefaultTypeInternal _TagValuesByCountGetReq_default_instance_;
class TagValuesByCountGetReq_MetaEntry_DoNotUse;
struct TagValuesByCountGetReq_MetaEntry_DoNotUseDefaultTypeInternal;
extern TagValuesByCountGetReq_MetaEntry_DoNotUseDefaultTypeInternal _TagValuesByCountGetReq_MetaEntry_DoNotUse_default_instance_;
class TagValuesByCountGetResp;
struct TagValuesByCountGetRespDefaultTypeInternal;
extern TagValuesByCountGetRespDefaultTypeInternal _TagValuesByCountGetResp_default_instance_;
class TagValuesByCountGetResp_VsValue;
struct TagValuesByCountGetResp_VsValueDefaultTypeInternal;
extern TagValuesByCountGetResp_VsValueDefaultTypeInternal _TagValuesByCountGetResp_VsValue_default_instance_;
class TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse;
struct TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUseDefaultTypeInternal;
extern TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUseDefaultTypeInternal _TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse_default_instance_;
class TagValuesGetReq;
struct TagValuesGetReqDefaultTypeInternal;
extern TagValuesGetReqDefaultTypeInternal _TagValuesGetReq_default_instance_;
class TagValuesGetReq_ExtendEntry_DoNotUse;
struct TagValuesGetReq_ExtendEntry_DoNotUseDefaultTypeInternal;
extern TagValuesGetReq_ExtendEntry_DoNotUseDefaultTypeInternal _TagValuesGetReq_ExtendEntry_DoNotUse_default_instance_;
class TagValuesGetResp;
struct TagValuesGetRespDefaultTypeInternal;
extern TagValuesGetRespDefaultTypeInternal _TagValuesGetResp_default_instance_;
class TagValuesGetResp_VsValue;
struct TagValuesGetResp_VsValueDefaultTypeInternal;
extern TagValuesGetResp_VsValueDefaultTypeInternal _TagValuesGetResp_VsValue_default_instance_;
class TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse;
struct TagValuesGetResp_VsValue_ValueMapEntry_DoNotUseDefaultTypeInternal;
extern TagValuesGetResp_VsValue_ValueMapEntry_DoNotUseDefaultTypeInternal _TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse_default_instance_;
class VsValue;
struct VsValueDefaultTypeInternal;
extern VsValueDefaultTypeInternal _VsValue_default_instance_;
}  // namespace vs
PROTOBUF_NAMESPACE_OPEN
template<> ::vs::ConfigFileSetReq* Arena::CreateMaybeMessage<::vs::ConfigFileSetReq>(Arena*);
template<> ::vs::ConfigFileSetResp* Arena::CreateMaybeMessage<::vs::ConfigFileSetResp>(Arena*);
template<> ::vs::DbPingReq* Arena::CreateMaybeMessage<::vs::DbPingReq>(Arena*);
template<> ::vs::DbPingResp* Arena::CreateMaybeMessage<::vs::DbPingResp>(Arena*);
template<> ::vs::ErrInfo* Arena::CreateMaybeMessage<::vs::ErrInfo>(Arena*);
template<> ::vs::KVInfo* Arena::CreateMaybeMessage<::vs::KVInfo>(Arena*);
template<> ::vs::KVInfo_KvsEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::KVInfo_KvsEntry_DoNotUse>(Arena*);
template<> ::vs::TagCountByRangeGetReq* Arena::CreateMaybeMessage<::vs::TagCountByRangeGetReq>(Arena*);
template<> ::vs::TagCountByRangeGetResp* Arena::CreateMaybeMessage<::vs::TagCountByRangeGetResp>(Arena*);
template<> ::vs::TagDescGetReq* Arena::CreateMaybeMessage<::vs::TagDescGetReq>(Arena*);
template<> ::vs::TagDescGetResp* Arena::CreateMaybeMessage<::vs::TagDescGetResp>(Arena*);
template<> ::vs::TagDescGetResp_DescEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagDescGetResp_DescEntry_DoNotUse>(Arena*);
template<> ::vs::TagFeatureGetReq* Arena::CreateMaybeMessage<::vs::TagFeatureGetReq>(Arena*);
template<> ::vs::TagFeatureGetResp* Arena::CreateMaybeMessage<::vs::TagFeatureGetResp>(Arena*);
template<> ::vs::TagFeatureGetResp_FeatEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagFeatureGetResp_FeatEntry_DoNotUse>(Arena*);
template<> ::vs::TagListGetReq* Arena::CreateMaybeMessage<::vs::TagListGetReq>(Arena*);
template<> ::vs::TagListGetResp* Arena::CreateMaybeMessage<::vs::TagListGetResp>(Arena*);
template<> ::vs::TagListGetResp_Filed* Arena::CreateMaybeMessage<::vs::TagListGetResp_Filed>(Arena*);
template<> ::vs::TagListGetResp_TagInfoMap* Arena::CreateMaybeMessage<::vs::TagListGetResp_TagInfoMap>(Arena*);
template<> ::vs::TagListGetResp_TagInfoMap_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagListGetResp_TagInfoMap_InfoEntry_DoNotUse>(Arena*);
template<> ::vs::TagTimeSectionReq* Arena::CreateMaybeMessage<::vs::TagTimeSectionReq>(Arena*);
template<> ::vs::TagTimeSectionResp* Arena::CreateMaybeMessage<::vs::TagTimeSectionResp>(Arena*);
template<> ::vs::TagValuesByCountGetReq* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetReq>(Arena*);
template<> ::vs::TagValuesByCountGetReq_MetaEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetReq_MetaEntry_DoNotUse>(Arena*);
template<> ::vs::TagValuesByCountGetResp* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetResp>(Arena*);
template<> ::vs::TagValuesByCountGetResp_VsValue* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetResp_VsValue>(Arena*);
template<> ::vs::TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse>(Arena*);
template<> ::vs::TagValuesGetReq* Arena::CreateMaybeMessage<::vs::TagValuesGetReq>(Arena*);
template<> ::vs::TagValuesGetReq_ExtendEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagValuesGetReq_ExtendEntry_DoNotUse>(Arena*);
template<> ::vs::TagValuesGetResp* Arena::CreateMaybeMessage<::vs::TagValuesGetResp>(Arena*);
template<> ::vs::TagValuesGetResp_VsValue* Arena::CreateMaybeMessage<::vs::TagValuesGetResp_VsValue>(Arena*);
template<> ::vs::TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse* Arena::CreateMaybeMessage<::vs::TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse>(Arena*);
template<> ::vs::VsValue* Arena::CreateMaybeMessage<::vs::VsValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vs {

// ===================================================================

class KVInfo_KvsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<KVInfo_KvsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<KVInfo_KvsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  KVInfo_KvsEntry_DoNotUse();
  explicit constexpr KVInfo_KvsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit KVInfo_KvsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const KVInfo_KvsEntry_DoNotUse& other);
  static const KVInfo_KvsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const KVInfo_KvsEntry_DoNotUse*>(&_KVInfo_KvsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.KVInfo.KvsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.KVInfo.KvsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class KVInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.KVInfo) */ {
 public:
  inline KVInfo() : KVInfo(nullptr) {}
  ~KVInfo() override;
  explicit constexpr KVInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVInfo(const KVInfo& from);
  KVInfo(KVInfo&& from) noexcept
    : KVInfo() {
    *this = ::std::move(from);
  }

  inline KVInfo& operator=(const KVInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVInfo& operator=(KVInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVInfo* internal_default_instance() {
    return reinterpret_cast<const KVInfo*>(
               &_KVInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KVInfo& a, KVInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(KVInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KVInfo* New() const final {
    return new KVInfo();
  }

  KVInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KVInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KVInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.KVInfo";
  }
  protected:
  explicit KVInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 1,
  };
  // map<string, string> Kvs = 1;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_kvs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_kvs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      kvs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:vs.KVInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      KVInfo_KvsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> kvs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagCountByRangeGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagCountByRangeGetReq) */ {
 public:
  inline TagCountByRangeGetReq() : TagCountByRangeGetReq(nullptr) {}
  ~TagCountByRangeGetReq() override;
  explicit constexpr TagCountByRangeGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagCountByRangeGetReq(const TagCountByRangeGetReq& from);
  TagCountByRangeGetReq(TagCountByRangeGetReq&& from) noexcept
    : TagCountByRangeGetReq() {
    *this = ::std::move(from);
  }

  inline TagCountByRangeGetReq& operator=(const TagCountByRangeGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagCountByRangeGetReq& operator=(TagCountByRangeGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagCountByRangeGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagCountByRangeGetReq* internal_default_instance() {
    return reinterpret_cast<const TagCountByRangeGetReq*>(
               &_TagCountByRangeGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TagCountByRangeGetReq& a, TagCountByRangeGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagCountByRangeGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagCountByRangeGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagCountByRangeGetReq* New() const final {
    return new TagCountByRangeGetReq();
  }

  TagCountByRangeGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagCountByRangeGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagCountByRangeGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagCountByRangeGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagCountByRangeGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagCountByRangeGetReq";
  }
  protected:
  explicit TagCountByRangeGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 3,
    kKvsFieldNumber = 5,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kTagIdFieldNumber = 4,
  };
  // string TagName = 3;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // .vs.KVInfo Kvs = 5;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 TagId = 4;
  void clear_tagid();
  ::PROTOBUF_NAMESPACE_ID::int32 tagid() const;
  void set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tagid() const;
  void _internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagCountByRangeGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  ::PROTOBUF_NAMESPACE_ID::int32 tagid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagCountByRangeGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagCountByRangeGetResp) */ {
 public:
  inline TagCountByRangeGetResp() : TagCountByRangeGetResp(nullptr) {}
  ~TagCountByRangeGetResp() override;
  explicit constexpr TagCountByRangeGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagCountByRangeGetResp(const TagCountByRangeGetResp& from);
  TagCountByRangeGetResp(TagCountByRangeGetResp&& from) noexcept
    : TagCountByRangeGetResp() {
    *this = ::std::move(from);
  }

  inline TagCountByRangeGetResp& operator=(const TagCountByRangeGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagCountByRangeGetResp& operator=(TagCountByRangeGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagCountByRangeGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagCountByRangeGetResp* internal_default_instance() {
    return reinterpret_cast<const TagCountByRangeGetResp*>(
               &_TagCountByRangeGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TagCountByRangeGetResp& a, TagCountByRangeGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagCountByRangeGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagCountByRangeGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagCountByRangeGetResp* New() const final {
    return new TagCountByRangeGetResp();
  }

  TagCountByRangeGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagCountByRangeGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagCountByRangeGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagCountByRangeGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagCountByRangeGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagCountByRangeGetResp";
  }
  protected:
  explicit TagCountByRangeGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // int32 Count = 1;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagCountByRangeGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagListGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagListGetReq) */ {
 public:
  inline TagListGetReq() : TagListGetReq(nullptr) {}
  ~TagListGetReq() override;
  explicit constexpr TagListGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagListGetReq(const TagListGetReq& from);
  TagListGetReq(TagListGetReq&& from) noexcept
    : TagListGetReq() {
    *this = ::std::move(from);
  }

  inline TagListGetReq& operator=(const TagListGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListGetReq& operator=(TagListGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListGetReq* internal_default_instance() {
    return reinterpret_cast<const TagListGetReq*>(
               &_TagListGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TagListGetReq& a, TagListGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagListGetReq* New() const final {
    return new TagListGetReq();
  }

  TagListGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagListGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagListGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagListGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagListGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagListGetReq";
  }
  protected:
  explicit TagListGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kPortFieldNumber = 4,
    kKvsFieldNumber = 5,
    kPageFieldNumber = 6,
    kSizeFieldNumber = 7,
  };
  // string Addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_MUST_USE_RESULT std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string Username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string Port = 4;
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // .vs.KVInfo Kvs = 5;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Page = 6;
  void clear_page();
  ::PROTOBUF_NAMESPACE_ID::int32 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_page() const;
  void _internal_set_page(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Size = 7;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagListGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 page_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagListGetResp_Filed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagListGetResp.Filed) */ {
 public:
  inline TagListGetResp_Filed() : TagListGetResp_Filed(nullptr) {}
  ~TagListGetResp_Filed() override;
  explicit constexpr TagListGetResp_Filed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagListGetResp_Filed(const TagListGetResp_Filed& from);
  TagListGetResp_Filed(TagListGetResp_Filed&& from) noexcept
    : TagListGetResp_Filed() {
    *this = ::std::move(from);
  }

  inline TagListGetResp_Filed& operator=(const TagListGetResp_Filed& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListGetResp_Filed& operator=(TagListGetResp_Filed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListGetResp_Filed& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListGetResp_Filed* internal_default_instance() {
    return reinterpret_cast<const TagListGetResp_Filed*>(
               &_TagListGetResp_Filed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TagListGetResp_Filed& a, TagListGetResp_Filed& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListGetResp_Filed* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListGetResp_Filed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagListGetResp_Filed* New() const final {
    return new TagListGetResp_Filed();
  }

  TagListGetResp_Filed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagListGetResp_Filed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagListGetResp_Filed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagListGetResp_Filed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagListGetResp_Filed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagListGetResp.Filed";
  }
  protected:
  explicit TagListGetResp_Filed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kDescFieldNumber = 4,
    kDataLengthFieldNumber = 3,
  };
  // string ColumnName = 1;
  void clear_columnname();
  const std::string& columnname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_columnname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_columnname();
  PROTOBUF_MUST_USE_RESULT std::string* release_columnname();
  void set_allocated_columnname(std::string* columnname);
  private:
  const std::string& _internal_columnname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_columnname(const std::string& value);
  std::string* _internal_mutable_columnname();
  public:

  // string DataType = 2;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_MUST_USE_RESULT std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // string Desc = 4;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_MUST_USE_RESULT std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // int32 DataLength = 3;
  void clear_datalength();
  ::PROTOBUF_NAMESPACE_ID::int32 datalength() const;
  void set_datalength(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_datalength() const;
  void _internal_set_datalength(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagListGetResp.Filed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr columnname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::PROTOBUF_NAMESPACE_ID::int32 datalength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagListGetResp_TagInfoMap_InfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagListGetResp_TagInfoMap_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagListGetResp_TagInfoMap_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TagListGetResp_TagInfoMap_InfoEntry_DoNotUse();
  explicit constexpr TagListGetResp_TagInfoMap_InfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagListGetResp_TagInfoMap_InfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagListGetResp_TagInfoMap_InfoEntry_DoNotUse& other);
  static const TagListGetResp_TagInfoMap_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagListGetResp_TagInfoMap_InfoEntry_DoNotUse*>(&_TagListGetResp_TagInfoMap_InfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagListGetResp.TagInfoMap.InfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagListGetResp.TagInfoMap.InfoEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagListGetResp_TagInfoMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagListGetResp.TagInfoMap) */ {
 public:
  inline TagListGetResp_TagInfoMap() : TagListGetResp_TagInfoMap(nullptr) {}
  ~TagListGetResp_TagInfoMap() override;
  explicit constexpr TagListGetResp_TagInfoMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagListGetResp_TagInfoMap(const TagListGetResp_TagInfoMap& from);
  TagListGetResp_TagInfoMap(TagListGetResp_TagInfoMap&& from) noexcept
    : TagListGetResp_TagInfoMap() {
    *this = ::std::move(from);
  }

  inline TagListGetResp_TagInfoMap& operator=(const TagListGetResp_TagInfoMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListGetResp_TagInfoMap& operator=(TagListGetResp_TagInfoMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListGetResp_TagInfoMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListGetResp_TagInfoMap* internal_default_instance() {
    return reinterpret_cast<const TagListGetResp_TagInfoMap*>(
               &_TagListGetResp_TagInfoMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TagListGetResp_TagInfoMap& a, TagListGetResp_TagInfoMap& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListGetResp_TagInfoMap* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListGetResp_TagInfoMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagListGetResp_TagInfoMap* New() const final {
    return new TagListGetResp_TagInfoMap();
  }

  TagListGetResp_TagInfoMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagListGetResp_TagInfoMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagListGetResp_TagInfoMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagListGetResp_TagInfoMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagListGetResp_TagInfoMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagListGetResp.TagInfoMap";
  }
  protected:
  explicit TagListGetResp_TagInfoMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kFiledsFieldNumber = 2,
  };
  // map<string, string> Info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_info();

  // repeated .vs.TagListGetResp.Filed Fileds = 2;
  int fileds_size() const;
  private:
  int _internal_fileds_size() const;
  public:
  void clear_fileds();
  ::vs::TagListGetResp_Filed* mutable_fileds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_Filed >*
      mutable_fileds();
  private:
  const ::vs::TagListGetResp_Filed& _internal_fileds(int index) const;
  ::vs::TagListGetResp_Filed* _internal_add_fileds();
  public:
  const ::vs::TagListGetResp_Filed& fileds(int index) const;
  ::vs::TagListGetResp_Filed* add_fileds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_Filed >&
      fileds() const;

  // @@protoc_insertion_point(class_scope:vs.TagListGetResp.TagInfoMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagListGetResp_TagInfoMap_InfoEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_Filed > fileds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagListGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagListGetResp) */ {
 public:
  inline TagListGetResp() : TagListGetResp(nullptr) {}
  ~TagListGetResp() override;
  explicit constexpr TagListGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagListGetResp(const TagListGetResp& from);
  TagListGetResp(TagListGetResp&& from) noexcept
    : TagListGetResp() {
    *this = ::std::move(from);
  }

  inline TagListGetResp& operator=(const TagListGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagListGetResp& operator=(TagListGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagListGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagListGetResp* internal_default_instance() {
    return reinterpret_cast<const TagListGetResp*>(
               &_TagListGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TagListGetResp& a, TagListGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagListGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagListGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagListGetResp* New() const final {
    return new TagListGetResp();
  }

  TagListGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagListGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagListGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagListGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagListGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagListGetResp";
  }
  protected:
  explicit TagListGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TagListGetResp_Filed Filed;
  typedef TagListGetResp_TagInfoMap TagInfoMap;

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
  };
  // repeated .vs.TagListGetResp.TagInfoMap Tags = 1;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::vs::TagListGetResp_TagInfoMap* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >*
      mutable_tags();
  private:
  const ::vs::TagListGetResp_TagInfoMap& _internal_tags(int index) const;
  ::vs::TagListGetResp_TagInfoMap* _internal_add_tags();
  public:
  const ::vs::TagListGetResp_TagInfoMap& tags(int index) const;
  ::vs::TagListGetResp_TagInfoMap* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >&
      tags() const;

  // @@protoc_insertion_point(class_scope:vs.TagListGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap > tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ConfigFileSetReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vs.ConfigFileSetReq) */ {
 public:
  inline ConfigFileSetReq() : ConfigFileSetReq(nullptr) {}
  explicit constexpr ConfigFileSetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigFileSetReq(const ConfigFileSetReq& from);
  ConfigFileSetReq(ConfigFileSetReq&& from) noexcept
    : ConfigFileSetReq() {
    *this = ::std::move(from);
  }

  inline ConfigFileSetReq& operator=(const ConfigFileSetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigFileSetReq& operator=(ConfigFileSetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigFileSetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigFileSetReq* internal_default_instance() {
    return reinterpret_cast<const ConfigFileSetReq*>(
               &_ConfigFileSetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConfigFileSetReq& a, ConfigFileSetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigFileSetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigFileSetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigFileSetReq* New() const final {
    return new ConfigFileSetReq();
  }

  ConfigFileSetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigFileSetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConfigFileSetReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConfigFileSetReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ConfigFileSetReq";
  }
  protected:
  explicit ConfigFileSetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vs.ConfigFileSetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ConfigFileSetResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:vs.ConfigFileSetResp) */ {
 public:
  inline ConfigFileSetResp() : ConfigFileSetResp(nullptr) {}
  explicit constexpr ConfigFileSetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigFileSetResp(const ConfigFileSetResp& from);
  ConfigFileSetResp(ConfigFileSetResp&& from) noexcept
    : ConfigFileSetResp() {
    *this = ::std::move(from);
  }

  inline ConfigFileSetResp& operator=(const ConfigFileSetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigFileSetResp& operator=(ConfigFileSetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigFileSetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigFileSetResp* internal_default_instance() {
    return reinterpret_cast<const ConfigFileSetResp*>(
               &_ConfigFileSetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ConfigFileSetResp& a, ConfigFileSetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigFileSetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigFileSetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigFileSetResp* New() const final {
    return new ConfigFileSetResp();
  }

  ConfigFileSetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigFileSetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConfigFileSetResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConfigFileSetResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ConfigFileSetResp";
  }
  protected:
  explicit ConfigFileSetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vs.ConfigFileSetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class DbPingReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.DbPingReq) */ {
 public:
  inline DbPingReq() : DbPingReq(nullptr) {}
  ~DbPingReq() override;
  explicit constexpr DbPingReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DbPingReq(const DbPingReq& from);
  DbPingReq(DbPingReq&& from) noexcept
    : DbPingReq() {
    *this = ::std::move(from);
  }

  inline DbPingReq& operator=(const DbPingReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DbPingReq& operator=(DbPingReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DbPingReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DbPingReq* internal_default_instance() {
    return reinterpret_cast<const DbPingReq*>(
               &_DbPingReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DbPingReq& a, DbPingReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DbPingReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DbPingReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DbPingReq* New() const final {
    return new DbPingReq();
  }

  DbPingReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DbPingReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DbPingReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DbPingReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DbPingReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.DbPingReq";
  }
  protected:
  explicit DbPingReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kUsernameFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kKvsFieldNumber = 5,
    kPortFieldNumber = 2,
  };
  // string Ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string Username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .vs.KVInfo Kvs = 5;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.DbPingReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class DbPingResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.DbPingResp) */ {
 public:
  inline DbPingResp() : DbPingResp(nullptr) {}
  ~DbPingResp() override;
  explicit constexpr DbPingResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DbPingResp(const DbPingResp& from);
  DbPingResp(DbPingResp&& from) noexcept
    : DbPingResp() {
    *this = ::std::move(from);
  }

  inline DbPingResp& operator=(const DbPingResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DbPingResp& operator=(DbPingResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DbPingResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DbPingResp* internal_default_instance() {
    return reinterpret_cast<const DbPingResp*>(
               &_DbPingResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DbPingResp& a, DbPingResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DbPingResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DbPingResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DbPingResp* New() const final {
    return new DbPingResp();
  }

  DbPingResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DbPingResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DbPingResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DbPingResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DbPingResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.DbPingResp";
  }
  protected:
  explicit DbPingResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
  };
  // int32 Flag = 1;
  void clear_flag();
  ::PROTOBUF_NAMESPACE_ID::int32 flag() const;
  void set_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flag() const;
  void _internal_set_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.DbPingResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 flag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class ErrInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.ErrInfo) */ {
 public:
  inline ErrInfo() : ErrInfo(nullptr) {}
  ~ErrInfo() override;
  explicit constexpr ErrInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrInfo(const ErrInfo& from);
  ErrInfo(ErrInfo&& from) noexcept
    : ErrInfo() {
    *this = ::std::move(from);
  }

  inline ErrInfo& operator=(const ErrInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrInfo& operator=(ErrInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrInfo* internal_default_instance() {
    return reinterpret_cast<const ErrInfo*>(
               &_ErrInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ErrInfo& a, ErrInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrInfo* New() const final {
    return new ErrInfo();
  }

  ErrInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ErrInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.ErrInfo";
  }
  protected:
  explicit ErrInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrMsgFieldNumber = 2,
    kErrCodeFieldNumber = 1,
  };
  // string ErrMsg = 2;
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // int32 ErrCode = 1;
  void clear_errcode();
  ::PROTOBUF_NAMESPACE_ID::int32 errcode() const;
  void set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_errcode() const;
  void _internal_set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.ErrInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::int32 errcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class VsValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.VsValue) */ {
 public:
  inline VsValue() : VsValue(nullptr) {}
  ~VsValue() override;
  explicit constexpr VsValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VsValue(const VsValue& from);
  VsValue(VsValue&& from) noexcept
    : VsValue() {
    *this = ::std::move(from);
  }

  inline VsValue& operator=(const VsValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline VsValue& operator=(VsValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VsValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const VsValue* internal_default_instance() {
    return reinterpret_cast<const VsValue*>(
               &_VsValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VsValue& a, VsValue& b) {
    a.Swap(&b);
  }
  inline void Swap(VsValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VsValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VsValue* New() const final {
    return new VsValue();
  }

  VsValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VsValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VsValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VsValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VsValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.VsValue";
  }
  protected:
  explicit VsValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTimeFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // double Value = 1;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // int32 Time = 2;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Status = 3;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.VsValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double value_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesByCountGetReq_MetaEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesByCountGetReq_MetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesByCountGetReq_MetaEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TagValuesByCountGetReq_MetaEntry_DoNotUse();
  explicit constexpr TagValuesByCountGetReq_MetaEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagValuesByCountGetReq_MetaEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagValuesByCountGetReq_MetaEntry_DoNotUse& other);
  static const TagValuesByCountGetReq_MetaEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagValuesByCountGetReq_MetaEntry_DoNotUse*>(&_TagValuesByCountGetReq_MetaEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesByCountGetReq.MetaEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesByCountGetReq.MetaEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagValuesByCountGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesByCountGetReq) */ {
 public:
  inline TagValuesByCountGetReq() : TagValuesByCountGetReq(nullptr) {}
  ~TagValuesByCountGetReq() override;
  explicit constexpr TagValuesByCountGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesByCountGetReq(const TagValuesByCountGetReq& from);
  TagValuesByCountGetReq(TagValuesByCountGetReq&& from) noexcept
    : TagValuesByCountGetReq() {
    *this = ::std::move(from);
  }

  inline TagValuesByCountGetReq& operator=(const TagValuesByCountGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesByCountGetReq& operator=(TagValuesByCountGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesByCountGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesByCountGetReq* internal_default_instance() {
    return reinterpret_cast<const TagValuesByCountGetReq*>(
               &_TagValuesByCountGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TagValuesByCountGetReq& a, TagValuesByCountGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesByCountGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesByCountGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesByCountGetReq* New() const final {
    return new TagValuesByCountGetReq();
  }

  TagValuesByCountGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesByCountGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesByCountGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesByCountGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesByCountGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesByCountGetReq";
  }
  protected:
  explicit TagValuesByCountGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 10,
    kTagNameFieldNumber = 3,
    kAddrFieldNumber = 5,
    kUsernameFieldNumber = 6,
    kPasswordFieldNumber = 7,
    kKvsFieldNumber = 9,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kTagIdFieldNumber = 4,
    kCountFieldNumber = 8,
  };
  // map<string, string> Meta = 10;
  int meta_size() const;
  private:
  int _internal_meta_size() const;
  public:
  void clear_meta();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_meta();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      meta() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_meta();

  // string TagName = 3;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // string Addr = 5;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_MUST_USE_RESULT std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string Username = 6;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 7;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .vs.KVInfo Kvs = 9;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 TagId = 4;
  void clear_tagid();
  ::PROTOBUF_NAMESPACE_ID::int32 tagid() const;
  void set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tagid() const;
  void _internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Count = 8;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagValuesByCountGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagValuesByCountGetReq_MetaEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> meta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  ::PROTOBUF_NAMESPACE_ID::int32 tagid_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse();
  explicit constexpr TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse& other);
  static const TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse*>(&_TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesByCountGetResp.VsValue.ValueMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesByCountGetResp.VsValue.ValueMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagValuesByCountGetResp_VsValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesByCountGetResp.VsValue) */ {
 public:
  inline TagValuesByCountGetResp_VsValue() : TagValuesByCountGetResp_VsValue(nullptr) {}
  ~TagValuesByCountGetResp_VsValue() override;
  explicit constexpr TagValuesByCountGetResp_VsValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesByCountGetResp_VsValue(const TagValuesByCountGetResp_VsValue& from);
  TagValuesByCountGetResp_VsValue(TagValuesByCountGetResp_VsValue&& from) noexcept
    : TagValuesByCountGetResp_VsValue() {
    *this = ::std::move(from);
  }

  inline TagValuesByCountGetResp_VsValue& operator=(const TagValuesByCountGetResp_VsValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesByCountGetResp_VsValue& operator=(TagValuesByCountGetResp_VsValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesByCountGetResp_VsValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesByCountGetResp_VsValue* internal_default_instance() {
    return reinterpret_cast<const TagValuesByCountGetResp_VsValue*>(
               &_TagValuesByCountGetResp_VsValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TagValuesByCountGetResp_VsValue& a, TagValuesByCountGetResp_VsValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesByCountGetResp_VsValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesByCountGetResp_VsValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesByCountGetResp_VsValue* New() const final {
    return new TagValuesByCountGetResp_VsValue();
  }

  TagValuesByCountGetResp_VsValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesByCountGetResp_VsValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesByCountGetResp_VsValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesByCountGetResp_VsValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesByCountGetResp_VsValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesByCountGetResp.VsValue";
  }
  protected:
  explicit TagValuesByCountGetResp_VsValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValueMapFieldNumber = 1,
  };
  // map<string, string> ValueMap = 1;
  int valuemap_size() const;
  private:
  int _internal_valuemap_size() const;
  public:
  void clear_valuemap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_valuemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_valuemap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      valuemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_valuemap();

  // @@protoc_insertion_point(class_scope:vs.TagValuesByCountGetResp.VsValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagValuesByCountGetResp_VsValue_ValueMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> valuemap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesByCountGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesByCountGetResp) */ {
 public:
  inline TagValuesByCountGetResp() : TagValuesByCountGetResp(nullptr) {}
  ~TagValuesByCountGetResp() override;
  explicit constexpr TagValuesByCountGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesByCountGetResp(const TagValuesByCountGetResp& from);
  TagValuesByCountGetResp(TagValuesByCountGetResp&& from) noexcept
    : TagValuesByCountGetResp() {
    *this = ::std::move(from);
  }

  inline TagValuesByCountGetResp& operator=(const TagValuesByCountGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesByCountGetResp& operator=(TagValuesByCountGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesByCountGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesByCountGetResp* internal_default_instance() {
    return reinterpret_cast<const TagValuesByCountGetResp*>(
               &_TagValuesByCountGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TagValuesByCountGetResp& a, TagValuesByCountGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesByCountGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesByCountGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesByCountGetResp* New() const final {
    return new TagValuesByCountGetResp();
  }

  TagValuesByCountGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesByCountGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesByCountGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesByCountGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesByCountGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesByCountGetResp";
  }
  protected:
  explicit TagValuesByCountGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TagValuesByCountGetResp_VsValue VsValue;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kValueTypeFieldNumber = 3,
    kErrFieldNumber = 1,
    kStartFieldNumber = 4,
    kEndFieldNumber = 5,
    kIsLastFieldNumber = 6,
  };
  // repeated .vs.TagValuesByCountGetResp.VsValue Values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::vs::TagValuesByCountGetResp_VsValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesByCountGetResp_VsValue >*
      mutable_values();
  private:
  const ::vs::TagValuesByCountGetResp_VsValue& _internal_values(int index) const;
  ::vs::TagValuesByCountGetResp_VsValue* _internal_add_values();
  public:
  const ::vs::TagValuesByCountGetResp_VsValue& values(int index) const;
  ::vs::TagValuesByCountGetResp_VsValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesByCountGetResp_VsValue >&
      values() const;

  // string ValueType = 3;
  void clear_valuetype();
  const std::string& valuetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valuetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valuetype();
  PROTOBUF_MUST_USE_RESULT std::string* release_valuetype();
  void set_allocated_valuetype(std::string* valuetype);
  private:
  const std::string& _internal_valuetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valuetype(const std::string& value);
  std::string* _internal_mutable_valuetype();
  public:

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 4;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 5;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool IsLast = 6;
  void clear_islast();
  bool islast() const;
  void set_islast(bool value);
  private:
  bool _internal_islast() const;
  void _internal_set_islast(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagValuesByCountGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesByCountGetResp_VsValue > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valuetype_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  bool islast_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesGetReq_ExtendEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesGetReq_ExtendEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesGetReq_ExtendEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TagValuesGetReq_ExtendEntry_DoNotUse();
  explicit constexpr TagValuesGetReq_ExtendEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagValuesGetReq_ExtendEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagValuesGetReq_ExtendEntry_DoNotUse& other);
  static const TagValuesGetReq_ExtendEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagValuesGetReq_ExtendEntry_DoNotUse*>(&_TagValuesGetReq_ExtendEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesGetReq.ExtendEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesGetReq.ExtendEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagValuesGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesGetReq) */ {
 public:
  inline TagValuesGetReq() : TagValuesGetReq(nullptr) {}
  ~TagValuesGetReq() override;
  explicit constexpr TagValuesGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesGetReq(const TagValuesGetReq& from);
  TagValuesGetReq(TagValuesGetReq&& from) noexcept
    : TagValuesGetReq() {
    *this = ::std::move(from);
  }

  inline TagValuesGetReq& operator=(const TagValuesGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesGetReq& operator=(TagValuesGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesGetReq* internal_default_instance() {
    return reinterpret_cast<const TagValuesGetReq*>(
               &_TagValuesGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TagValuesGetReq& a, TagValuesGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesGetReq* New() const final {
    return new TagValuesGetReq();
  }

  TagValuesGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesGetReq";
  }
  protected:
  explicit TagValuesGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtendFieldNumber = 10,
    kTagNameFieldNumber = 3,
    kAddrFieldNumber = 5,
    kUsernameFieldNumber = 6,
    kPasswordFieldNumber = 7,
    kKvsFieldNumber = 9,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kTagIdFieldNumber = 4,
    kCountFieldNumber = 8,
  };
  // map<string, string> Extend = 10;
  int extend_size() const;
  private:
  int _internal_extend_size() const;
  public:
  void clear_extend();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extend() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extend();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extend() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extend();

  // string TagName = 3;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // string Addr = 5;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_MUST_USE_RESULT std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string Username = 6;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 7;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .vs.KVInfo Kvs = 9;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 Start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 TagId = 4;
  void clear_tagid();
  ::PROTOBUF_NAMESPACE_ID::int32 tagid() const;
  void set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tagid() const;
  void _internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Count = 8;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagValuesGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagValuesGetReq_ExtendEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> extend_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  ::PROTOBUF_NAMESPACE_ID::int32 tagid_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse();
  explicit constexpr TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse& other);
  static const TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse*>(&_TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesGetResp.VsValue.ValueMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagValuesGetResp.VsValue.ValueMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagValuesGetResp_VsValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesGetResp.VsValue) */ {
 public:
  inline TagValuesGetResp_VsValue() : TagValuesGetResp_VsValue(nullptr) {}
  ~TagValuesGetResp_VsValue() override;
  explicit constexpr TagValuesGetResp_VsValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesGetResp_VsValue(const TagValuesGetResp_VsValue& from);
  TagValuesGetResp_VsValue(TagValuesGetResp_VsValue&& from) noexcept
    : TagValuesGetResp_VsValue() {
    *this = ::std::move(from);
  }

  inline TagValuesGetResp_VsValue& operator=(const TagValuesGetResp_VsValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesGetResp_VsValue& operator=(TagValuesGetResp_VsValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesGetResp_VsValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesGetResp_VsValue* internal_default_instance() {
    return reinterpret_cast<const TagValuesGetResp_VsValue*>(
               &_TagValuesGetResp_VsValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TagValuesGetResp_VsValue& a, TagValuesGetResp_VsValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesGetResp_VsValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesGetResp_VsValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesGetResp_VsValue* New() const final {
    return new TagValuesGetResp_VsValue();
  }

  TagValuesGetResp_VsValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesGetResp_VsValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesGetResp_VsValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesGetResp_VsValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesGetResp_VsValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesGetResp.VsValue";
  }
  protected:
  explicit TagValuesGetResp_VsValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValueMapFieldNumber = 1,
  };
  // map<string, string> ValueMap = 1;
  int valuemap_size() const;
  private:
  int _internal_valuemap_size() const;
  public:
  void clear_valuemap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_valuemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_valuemap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      valuemap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_valuemap();

  // @@protoc_insertion_point(class_scope:vs.TagValuesGetResp.VsValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagValuesGetResp_VsValue_ValueMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> valuemap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagValuesGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagValuesGetResp) */ {
 public:
  inline TagValuesGetResp() : TagValuesGetResp(nullptr) {}
  ~TagValuesGetResp() override;
  explicit constexpr TagValuesGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagValuesGetResp(const TagValuesGetResp& from);
  TagValuesGetResp(TagValuesGetResp&& from) noexcept
    : TagValuesGetResp() {
    *this = ::std::move(from);
  }

  inline TagValuesGetResp& operator=(const TagValuesGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagValuesGetResp& operator=(TagValuesGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagValuesGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagValuesGetResp* internal_default_instance() {
    return reinterpret_cast<const TagValuesGetResp*>(
               &_TagValuesGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TagValuesGetResp& a, TagValuesGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagValuesGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagValuesGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagValuesGetResp* New() const final {
    return new TagValuesGetResp();
  }

  TagValuesGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagValuesGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagValuesGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagValuesGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagValuesGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagValuesGetResp";
  }
  protected:
  explicit TagValuesGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TagValuesGetResp_VsValue VsValue;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kErrFieldNumber = 1,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // repeated .vs.TagValuesGetResp.VsValue Values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::vs::TagValuesGetResp_VsValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesGetResp_VsValue >*
      mutable_values();
  private:
  const ::vs::TagValuesGetResp_VsValue& _internal_values(int index) const;
  ::vs::TagValuesGetResp_VsValue* _internal_add_values();
  public:
  const ::vs::TagValuesGetResp_VsValue& values(int index) const;
  ::vs::TagValuesGetResp_VsValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesGetResp_VsValue >&
      values() const;

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 3;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 4;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagValuesGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesGetResp_VsValue > values_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagFeatureGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagFeatureGetReq) */ {
 public:
  inline TagFeatureGetReq() : TagFeatureGetReq(nullptr) {}
  ~TagFeatureGetReq() override;
  explicit constexpr TagFeatureGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagFeatureGetReq(const TagFeatureGetReq& from);
  TagFeatureGetReq(TagFeatureGetReq&& from) noexcept
    : TagFeatureGetReq() {
    *this = ::std::move(from);
  }

  inline TagFeatureGetReq& operator=(const TagFeatureGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagFeatureGetReq& operator=(TagFeatureGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagFeatureGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagFeatureGetReq* internal_default_instance() {
    return reinterpret_cast<const TagFeatureGetReq*>(
               &_TagFeatureGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TagFeatureGetReq& a, TagFeatureGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagFeatureGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagFeatureGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagFeatureGetReq* New() const final {
    return new TagFeatureGetReq();
  }

  TagFeatureGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagFeatureGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagFeatureGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagFeatureGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagFeatureGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagFeatureGetReq";
  }
  protected:
  explicit TagFeatureGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerifiesFieldNumber = 5,
    kTagNameFieldNumber = 3,
    kAddrFieldNumber = 7,
    kUsernameFieldNumber = 8,
    kPasswordFieldNumber = 9,
    kKvsFieldNumber = 10,
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kTagIdFieldNumber = 4,
    kCountFieldNumber = 6,
  };
  // repeated int32 Verifies = 5;
  int verifies_size() const;
  private:
  int _internal_verifies_size() const;
  public:
  void clear_verifies();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_verifies(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_verifies() const;
  void _internal_add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_verifies();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 verifies(int index) const;
  void set_verifies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      verifies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_verifies();

  // string TagName = 3;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // string Addr = 7;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_MUST_USE_RESULT std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string Username = 8;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 9;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .vs.KVInfo Kvs = 10;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int64 Start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int64 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 End = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int64 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 TagId = 4;
  void clear_tagid();
  ::PROTOBUF_NAMESPACE_ID::int32 tagid() const;
  void set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tagid() const;
  void _internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Count = 6;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagFeatureGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > verifies_;
  mutable std::atomic<int> _verifies_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_;
  ::PROTOBUF_NAMESPACE_ID::int32 tagid_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagFeatureGetResp_FeatEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagFeatureGetResp_FeatEntry_DoNotUse, 
    std::string, ::vs::VsValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagFeatureGetResp_FeatEntry_DoNotUse, 
    std::string, ::vs::VsValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TagFeatureGetResp_FeatEntry_DoNotUse();
  explicit constexpr TagFeatureGetResp_FeatEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagFeatureGetResp_FeatEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagFeatureGetResp_FeatEntry_DoNotUse& other);
  static const TagFeatureGetResp_FeatEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagFeatureGetResp_FeatEntry_DoNotUse*>(&_TagFeatureGetResp_FeatEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagFeatureGetResp.FeatEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagFeatureGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagFeatureGetResp) */ {
 public:
  inline TagFeatureGetResp() : TagFeatureGetResp(nullptr) {}
  ~TagFeatureGetResp() override;
  explicit constexpr TagFeatureGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagFeatureGetResp(const TagFeatureGetResp& from);
  TagFeatureGetResp(TagFeatureGetResp&& from) noexcept
    : TagFeatureGetResp() {
    *this = ::std::move(from);
  }

  inline TagFeatureGetResp& operator=(const TagFeatureGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagFeatureGetResp& operator=(TagFeatureGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagFeatureGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagFeatureGetResp* internal_default_instance() {
    return reinterpret_cast<const TagFeatureGetResp*>(
               &_TagFeatureGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TagFeatureGetResp& a, TagFeatureGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagFeatureGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagFeatureGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagFeatureGetResp* New() const final {
    return new TagFeatureGetResp();
  }

  TagFeatureGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagFeatureGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagFeatureGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagFeatureGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagFeatureGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagFeatureGetResp";
  }
  protected:
  explicit TagFeatureGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFeatFieldNumber = 2,
    kErrFieldNumber = 1,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
  };
  // map<string, .vs.VsValue> Feat = 2;
  int feat_size() const;
  private:
  int _internal_feat_size() const;
  public:
  void clear_feat();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
      _internal_feat() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
      _internal_mutable_feat();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
      feat() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
      mutable_feat();

  // .vs.ErrInfo Err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::vs::ErrInfo& err() const;
  PROTOBUF_MUST_USE_RESULT ::vs::ErrInfo* release_err();
  ::vs::ErrInfo* mutable_err();
  void set_allocated_err(::vs::ErrInfo* err);
  private:
  const ::vs::ErrInfo& _internal_err() const;
  ::vs::ErrInfo* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::vs::ErrInfo* err);
  ::vs::ErrInfo* unsafe_arena_release_err();

  // int32 Start = 3;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 4;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagFeatureGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagFeatureGetResp_FeatEntry_DoNotUse,
      std::string, ::vs::VsValue,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> feat_;
  ::vs::ErrInfo* err_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagDescGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagDescGetReq) */ {
 public:
  inline TagDescGetReq() : TagDescGetReq(nullptr) {}
  ~TagDescGetReq() override;
  explicit constexpr TagDescGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagDescGetReq(const TagDescGetReq& from);
  TagDescGetReq(TagDescGetReq&& from) noexcept
    : TagDescGetReq() {
    *this = ::std::move(from);
  }

  inline TagDescGetReq& operator=(const TagDescGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagDescGetReq& operator=(TagDescGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagDescGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagDescGetReq* internal_default_instance() {
    return reinterpret_cast<const TagDescGetReq*>(
               &_TagDescGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TagDescGetReq& a, TagDescGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagDescGetReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagDescGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagDescGetReq* New() const final {
    return new TagDescGetReq();
  }

  TagDescGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagDescGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagDescGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagDescGetReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagDescGetReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagDescGetReq";
  }
  protected:
  explicit TagDescGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 1,
  };
  // .vs.KVInfo Kvs = 1;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // @@protoc_insertion_point(class_scope:vs.TagDescGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vs::KVInfo* kvs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagDescGetResp_DescEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagDescGetResp_DescEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TagDescGetResp_DescEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TagDescGetResp_DescEntry_DoNotUse();
  explicit constexpr TagDescGetResp_DescEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TagDescGetResp_DescEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TagDescGetResp_DescEntry_DoNotUse& other);
  static const TagDescGetResp_DescEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TagDescGetResp_DescEntry_DoNotUse*>(&_TagDescGetResp_DescEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagDescGetResp.DescEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vs.TagDescGetResp.DescEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TagDescGetResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagDescGetResp) */ {
 public:
  inline TagDescGetResp() : TagDescGetResp(nullptr) {}
  ~TagDescGetResp() override;
  explicit constexpr TagDescGetResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagDescGetResp(const TagDescGetResp& from);
  TagDescGetResp(TagDescGetResp&& from) noexcept
    : TagDescGetResp() {
    *this = ::std::move(from);
  }

  inline TagDescGetResp& operator=(const TagDescGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagDescGetResp& operator=(TagDescGetResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagDescGetResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagDescGetResp* internal_default_instance() {
    return reinterpret_cast<const TagDescGetResp*>(
               &_TagDescGetResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TagDescGetResp& a, TagDescGetResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagDescGetResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagDescGetResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagDescGetResp* New() const final {
    return new TagDescGetResp();
  }

  TagDescGetResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagDescGetResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagDescGetResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagDescGetResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagDescGetResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagDescGetResp";
  }
  protected:
  explicit TagDescGetResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDescFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // map<string, string> Desc = 2;
  int desc_size() const;
  private:
  int _internal_desc_size() const;
  public:
  void clear_desc();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_desc() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_desc();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      desc() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_desc();

  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vs.TagDescGetResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TagDescGetResp_DescEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagTimeSectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagTimeSectionReq) */ {
 public:
  inline TagTimeSectionReq() : TagTimeSectionReq(nullptr) {}
  ~TagTimeSectionReq() override;
  explicit constexpr TagTimeSectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagTimeSectionReq(const TagTimeSectionReq& from);
  TagTimeSectionReq(TagTimeSectionReq&& from) noexcept
    : TagTimeSectionReq() {
    *this = ::std::move(from);
  }

  inline TagTimeSectionReq& operator=(const TagTimeSectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTimeSectionReq& operator=(TagTimeSectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTimeSectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTimeSectionReq* internal_default_instance() {
    return reinterpret_cast<const TagTimeSectionReq*>(
               &_TagTimeSectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TagTimeSectionReq& a, TagTimeSectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTimeSectionReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTimeSectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagTimeSectionReq* New() const final {
    return new TagTimeSectionReq();
  }

  TagTimeSectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagTimeSectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagTimeSectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagTimeSectionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTimeSectionReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagTimeSectionReq";
  }
  protected:
  explicit TagTimeSectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagNameFieldNumber = 1,
    kAddrFieldNumber = 3,
    kUsernameFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kKvsFieldNumber = 8,
    kTagIdFieldNumber = 2,
    kStartFieldNumber = 6,
    kEndFieldNumber = 7,
  };
  // string TagName = 1;
  void clear_tagname();
  const std::string& tagname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagname();
  PROTOBUF_MUST_USE_RESULT std::string* release_tagname();
  void set_allocated_tagname(std::string* tagname);
  private:
  const std::string& _internal_tagname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagname(const std::string& value);
  std::string* _internal_mutable_tagname();
  public:

  // string Addr = 3;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_MUST_USE_RESULT std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string Username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string Password = 5;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .vs.KVInfo Kvs = 8;
  bool has_kvs() const;
  private:
  bool _internal_has_kvs() const;
  public:
  void clear_kvs();
  const ::vs::KVInfo& kvs() const;
  PROTOBUF_MUST_USE_RESULT ::vs::KVInfo* release_kvs();
  ::vs::KVInfo* mutable_kvs();
  void set_allocated_kvs(::vs::KVInfo* kvs);
  private:
  const ::vs::KVInfo& _internal_kvs() const;
  ::vs::KVInfo* _internal_mutable_kvs();
  public:
  void unsafe_arena_set_allocated_kvs(
      ::vs::KVInfo* kvs);
  ::vs::KVInfo* unsafe_arena_release_kvs();

  // int32 TagId = 2;
  void clear_tagid();
  ::PROTOBUF_NAMESPACE_ID::int32 tagid() const;
  void set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tagid() const;
  void _internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Start = 6;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 7;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagTimeSectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::vs::KVInfo* kvs_;
  ::PROTOBUF_NAMESPACE_ID::int32 tagid_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// -------------------------------------------------------------------

class TagTimeSectionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vs.TagTimeSectionResp) */ {
 public:
  inline TagTimeSectionResp() : TagTimeSectionResp(nullptr) {}
  ~TagTimeSectionResp() override;
  explicit constexpr TagTimeSectionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagTimeSectionResp(const TagTimeSectionResp& from);
  TagTimeSectionResp(TagTimeSectionResp&& from) noexcept
    : TagTimeSectionResp() {
    *this = ::std::move(from);
  }

  inline TagTimeSectionResp& operator=(const TagTimeSectionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagTimeSectionResp& operator=(TagTimeSectionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagTimeSectionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagTimeSectionResp* internal_default_instance() {
    return reinterpret_cast<const TagTimeSectionResp*>(
               &_TagTimeSectionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(TagTimeSectionResp& a, TagTimeSectionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TagTimeSectionResp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagTimeSectionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagTimeSectionResp* New() const final {
    return new TagTimeSectionResp();
  }

  TagTimeSectionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagTimeSectionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagTimeSectionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TagTimeSectionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagTimeSectionResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vs.TagTimeSectionResp";
  }
  protected:
  explicit TagTimeSectionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int32 Start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 End = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:vs.TagTimeSectionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// KVInfo

// map<string, string> Kvs = 1;
inline int KVInfo::_internal_kvs_size() const {
  return kvs_.size();
}
inline int KVInfo::kvs_size() const {
  return _internal_kvs_size();
}
inline void KVInfo::clear_kvs() {
  kvs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
KVInfo::_internal_kvs() const {
  return kvs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
KVInfo::kvs() const {
  // @@protoc_insertion_point(field_map:vs.KVInfo.Kvs)
  return _internal_kvs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
KVInfo::_internal_mutable_kvs() {
  return kvs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
KVInfo::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_map:vs.KVInfo.Kvs)
  return _internal_mutable_kvs();
}

// -------------------------------------------------------------------

// TagCountByRangeGetReq

// int32 Start = 1;
inline void TagCountByRangeGetReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.Start)
  return _internal_start();
}
inline void TagCountByRangeGetReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagCountByRangeGetReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.Start)
}

// int32 End = 2;
inline void TagCountByRangeGetReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.End)
  return _internal_end();
}
inline void TagCountByRangeGetReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagCountByRangeGetReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.End)
}

// string TagName = 3;
inline void TagCountByRangeGetReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagCountByRangeGetReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagCountByRangeGetReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.TagName)
}
inline std::string* TagCountByRangeGetReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagCountByRangeGetReq.TagName)
  return _s;
}
inline const std::string& TagCountByRangeGetReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagCountByRangeGetReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagCountByRangeGetReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagCountByRangeGetReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagCountByRangeGetReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagCountByRangeGetReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagCountByRangeGetReq.TagName)
}

// int32 TagId = 4;
inline void TagCountByRangeGetReq::clear_tagid() {
  tagid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::_internal_tagid() const {
  return tagid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetReq::tagid() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.TagId)
  return _internal_tagid();
}
inline void TagCountByRangeGetReq::_internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tagid_ = value;
}
inline void TagCountByRangeGetReq::set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetReq.TagId)
}

// .vs.KVInfo Kvs = 5;
inline bool TagCountByRangeGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagCountByRangeGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagCountByRangeGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagCountByRangeGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagCountByRangeGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetReq.Kvs)
  return _internal_kvs();
}
inline void TagCountByRangeGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagCountByRangeGetReq.Kvs)
}
inline ::vs::KVInfo* TagCountByRangeGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagCountByRangeGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagCountByRangeGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagCountByRangeGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagCountByRangeGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagCountByRangeGetReq.Kvs)
  return _msg;
}
inline void TagCountByRangeGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagCountByRangeGetReq.Kvs)
}

// -------------------------------------------------------------------

// TagCountByRangeGetResp

// int32 Count = 1;
inline void TagCountByRangeGetResp::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetResp::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagCountByRangeGetResp::count() const {
  // @@protoc_insertion_point(field_get:vs.TagCountByRangeGetResp.Count)
  return _internal_count();
}
inline void TagCountByRangeGetResp::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagCountByRangeGetResp::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagCountByRangeGetResp.Count)
}

// -------------------------------------------------------------------

// TagListGetReq

// string Addr = 1;
inline void TagListGetReq::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& TagListGetReq::addr() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagListGetReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Addr)
}
inline std::string* TagListGetReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetReq.Addr)
  return _s;
}
inline const std::string& TagListGetReq::_internal_addr() const {
  return addr_.Get();
}
inline void TagListGetReq::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagListGetReq::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagListGetReq::release_addr() {
  // @@protoc_insertion_point(field_release:vs.TagListGetReq.Addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagListGetReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetReq.Addr)
}

// string Username = 2;
inline void TagListGetReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& TagListGetReq::username() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagListGetReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Username)
}
inline std::string* TagListGetReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetReq.Username)
  return _s;
}
inline const std::string& TagListGetReq::_internal_username() const {
  return username_.Get();
}
inline void TagListGetReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagListGetReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagListGetReq::release_username() {
  // @@protoc_insertion_point(field_release:vs.TagListGetReq.Username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagListGetReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetReq.Username)
}

// string Password = 3;
inline void TagListGetReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& TagListGetReq::password() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagListGetReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Password)
}
inline std::string* TagListGetReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetReq.Password)
  return _s;
}
inline const std::string& TagListGetReq::_internal_password() const {
  return password_.Get();
}
inline void TagListGetReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagListGetReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagListGetReq::release_password() {
  // @@protoc_insertion_point(field_release:vs.TagListGetReq.Password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagListGetReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetReq.Password)
}

// string Port = 4;
inline void TagListGetReq::clear_port() {
  port_.ClearToEmpty();
}
inline const std::string& TagListGetReq::port() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagListGetReq::set_port(ArgT0&& arg0, ArgT... args) {
 
 port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Port)
}
inline std::string* TagListGetReq::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetReq.Port)
  return _s;
}
inline const std::string& TagListGetReq::_internal_port() const {
  return port_.Get();
}
inline void TagListGetReq::_internal_set_port(const std::string& value) {
  
  port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagListGetReq::_internal_mutable_port() {
  
  return port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagListGetReq::release_port() {
  // @@protoc_insertion_point(field_release:vs.TagListGetReq.Port)
  return port_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagListGetReq::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetReq.Port)
}

// .vs.KVInfo Kvs = 5;
inline bool TagListGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagListGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagListGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagListGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagListGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Kvs)
  return _internal_kvs();
}
inline void TagListGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagListGetReq.Kvs)
}
inline ::vs::KVInfo* TagListGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagListGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagListGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagListGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagListGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetReq.Kvs)
  return _msg;
}
inline void TagListGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetReq.Kvs)
}

// int32 Page = 6;
inline void TagListGetReq::clear_page() {
  page_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::_internal_page() const {
  return page_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::page() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Page)
  return _internal_page();
}
inline void TagListGetReq::_internal_set_page(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  page_ = value;
}
inline void TagListGetReq::set_page(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Page)
}

// int32 Size = 7;
inline void TagListGetReq::clear_size() {
  size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetReq::size() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetReq.Size)
  return _internal_size();
}
inline void TagListGetReq::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  size_ = value;
}
inline void TagListGetReq::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:vs.TagListGetReq.Size)
}

// -------------------------------------------------------------------

// TagListGetResp_Filed

// string ColumnName = 1;
inline void TagListGetResp_Filed::clear_columnname() {
  columnname_.ClearToEmpty();
}
inline const std::string& TagListGetResp_Filed::columnname() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.Filed.ColumnName)
  return _internal_columnname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagListGetResp_Filed::set_columnname(ArgT0&& arg0, ArgT... args) {
 
 columnname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagListGetResp.Filed.ColumnName)
}
inline std::string* TagListGetResp_Filed::mutable_columnname() {
  std::string* _s = _internal_mutable_columnname();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetResp.Filed.ColumnName)
  return _s;
}
inline const std::string& TagListGetResp_Filed::_internal_columnname() const {
  return columnname_.Get();
}
inline void TagListGetResp_Filed::_internal_set_columnname(const std::string& value) {
  
  columnname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagListGetResp_Filed::_internal_mutable_columnname() {
  
  return columnname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagListGetResp_Filed::release_columnname() {
  // @@protoc_insertion_point(field_release:vs.TagListGetResp.Filed.ColumnName)
  return columnname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagListGetResp_Filed::set_allocated_columnname(std::string* columnname) {
  if (columnname != nullptr) {
    
  } else {
    
  }
  columnname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), columnname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetResp.Filed.ColumnName)
}

// string DataType = 2;
inline void TagListGetResp_Filed::clear_datatype() {
  datatype_.ClearToEmpty();
}
inline const std::string& TagListGetResp_Filed::datatype() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.Filed.DataType)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagListGetResp_Filed::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 datatype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagListGetResp.Filed.DataType)
}
inline std::string* TagListGetResp_Filed::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetResp.Filed.DataType)
  return _s;
}
inline const std::string& TagListGetResp_Filed::_internal_datatype() const {
  return datatype_.Get();
}
inline void TagListGetResp_Filed::_internal_set_datatype(const std::string& value) {
  
  datatype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagListGetResp_Filed::_internal_mutable_datatype() {
  
  return datatype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagListGetResp_Filed::release_datatype() {
  // @@protoc_insertion_point(field_release:vs.TagListGetResp.Filed.DataType)
  return datatype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagListGetResp_Filed::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  datatype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), datatype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetResp.Filed.DataType)
}

// int32 DataLength = 3;
inline void TagListGetResp_Filed::clear_datalength() {
  datalength_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetResp_Filed::_internal_datalength() const {
  return datalength_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagListGetResp_Filed::datalength() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.Filed.DataLength)
  return _internal_datalength();
}
inline void TagListGetResp_Filed::_internal_set_datalength(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  datalength_ = value;
}
inline void TagListGetResp_Filed::set_datalength(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_datalength(value);
  // @@protoc_insertion_point(field_set:vs.TagListGetResp.Filed.DataLength)
}

// string Desc = 4;
inline void TagListGetResp_Filed::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& TagListGetResp_Filed::desc() const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.Filed.Desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagListGetResp_Filed::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagListGetResp.Filed.Desc)
}
inline std::string* TagListGetResp_Filed::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:vs.TagListGetResp.Filed.Desc)
  return _s;
}
inline const std::string& TagListGetResp_Filed::_internal_desc() const {
  return desc_.Get();
}
inline void TagListGetResp_Filed::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagListGetResp_Filed::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagListGetResp_Filed::release_desc() {
  // @@protoc_insertion_point(field_release:vs.TagListGetResp.Filed.Desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagListGetResp_Filed::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagListGetResp.Filed.Desc)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagListGetResp_TagInfoMap

// map<string, string> Info = 1;
inline int TagListGetResp_TagInfoMap::_internal_info_size() const {
  return info_.size();
}
inline int TagListGetResp_TagInfoMap::info_size() const {
  return _internal_info_size();
}
inline void TagListGetResp_TagInfoMap::clear_info() {
  info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagListGetResp_TagInfoMap::_internal_info() const {
  return info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagListGetResp_TagInfoMap::info() const {
  // @@protoc_insertion_point(field_map:vs.TagListGetResp.TagInfoMap.Info)
  return _internal_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagListGetResp_TagInfoMap::_internal_mutable_info() {
  return info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagListGetResp_TagInfoMap::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagListGetResp.TagInfoMap.Info)
  return _internal_mutable_info();
}

// repeated .vs.TagListGetResp.Filed Fileds = 2;
inline int TagListGetResp_TagInfoMap::_internal_fileds_size() const {
  return fileds_.size();
}
inline int TagListGetResp_TagInfoMap::fileds_size() const {
  return _internal_fileds_size();
}
inline void TagListGetResp_TagInfoMap::clear_fileds() {
  fileds_.Clear();
}
inline ::vs::TagListGetResp_Filed* TagListGetResp_TagInfoMap::mutable_fileds(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagListGetResp.TagInfoMap.Fileds)
  return fileds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_Filed >*
TagListGetResp_TagInfoMap::mutable_fileds() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagListGetResp.TagInfoMap.Fileds)
  return &fileds_;
}
inline const ::vs::TagListGetResp_Filed& TagListGetResp_TagInfoMap::_internal_fileds(int index) const {
  return fileds_.Get(index);
}
inline const ::vs::TagListGetResp_Filed& TagListGetResp_TagInfoMap::fileds(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.TagInfoMap.Fileds)
  return _internal_fileds(index);
}
inline ::vs::TagListGetResp_Filed* TagListGetResp_TagInfoMap::_internal_add_fileds() {
  return fileds_.Add();
}
inline ::vs::TagListGetResp_Filed* TagListGetResp_TagInfoMap::add_fileds() {
  ::vs::TagListGetResp_Filed* _add = _internal_add_fileds();
  // @@protoc_insertion_point(field_add:vs.TagListGetResp.TagInfoMap.Fileds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_Filed >&
TagListGetResp_TagInfoMap::fileds() const {
  // @@protoc_insertion_point(field_list:vs.TagListGetResp.TagInfoMap.Fileds)
  return fileds_;
}

// -------------------------------------------------------------------

// TagListGetResp

// repeated .vs.TagListGetResp.TagInfoMap Tags = 1;
inline int TagListGetResp::_internal_tags_size() const {
  return tags_.size();
}
inline int TagListGetResp::tags_size() const {
  return _internal_tags_size();
}
inline void TagListGetResp::clear_tags() {
  tags_.Clear();
}
inline ::vs::TagListGetResp_TagInfoMap* TagListGetResp::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagListGetResp.Tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >*
TagListGetResp::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagListGetResp.Tags)
  return &tags_;
}
inline const ::vs::TagListGetResp_TagInfoMap& TagListGetResp::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::vs::TagListGetResp_TagInfoMap& TagListGetResp::tags(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagListGetResp.Tags)
  return _internal_tags(index);
}
inline ::vs::TagListGetResp_TagInfoMap* TagListGetResp::_internal_add_tags() {
  return tags_.Add();
}
inline ::vs::TagListGetResp_TagInfoMap* TagListGetResp::add_tags() {
  ::vs::TagListGetResp_TagInfoMap* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:vs.TagListGetResp.Tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagListGetResp_TagInfoMap >&
TagListGetResp::tags() const {
  // @@protoc_insertion_point(field_list:vs.TagListGetResp.Tags)
  return tags_;
}

// -------------------------------------------------------------------

// ConfigFileSetReq

// -------------------------------------------------------------------

// ConfigFileSetResp

// -------------------------------------------------------------------

// DbPingReq

// string Ip = 1;
inline void DbPingReq::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& DbPingReq::ip() const {
  // @@protoc_insertion_point(field_get:vs.DbPingReq.Ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbPingReq::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.DbPingReq.Ip)
}
inline std::string* DbPingReq::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:vs.DbPingReq.Ip)
  return _s;
}
inline const std::string& DbPingReq::_internal_ip() const {
  return ip_.Get();
}
inline void DbPingReq::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbPingReq::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbPingReq::release_ip() {
  // @@protoc_insertion_point(field_release:vs.DbPingReq.Ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbPingReq::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.DbPingReq.Ip)
}

// int32 Port = 2;
inline void DbPingReq::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DbPingReq::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DbPingReq::port() const {
  // @@protoc_insertion_point(field_get:vs.DbPingReq.Port)
  return _internal_port();
}
inline void DbPingReq::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void DbPingReq::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:vs.DbPingReq.Port)
}

// string Username = 3;
inline void DbPingReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& DbPingReq::username() const {
  // @@protoc_insertion_point(field_get:vs.DbPingReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbPingReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.DbPingReq.Username)
}
inline std::string* DbPingReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:vs.DbPingReq.Username)
  return _s;
}
inline const std::string& DbPingReq::_internal_username() const {
  return username_.Get();
}
inline void DbPingReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbPingReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbPingReq::release_username() {
  // @@protoc_insertion_point(field_release:vs.DbPingReq.Username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbPingReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.DbPingReq.Username)
}

// string Password = 4;
inline void DbPingReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& DbPingReq::password() const {
  // @@protoc_insertion_point(field_get:vs.DbPingReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbPingReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.DbPingReq.Password)
}
inline std::string* DbPingReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:vs.DbPingReq.Password)
  return _s;
}
inline const std::string& DbPingReq::_internal_password() const {
  return password_.Get();
}
inline void DbPingReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbPingReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbPingReq::release_password() {
  // @@protoc_insertion_point(field_release:vs.DbPingReq.Password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbPingReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.DbPingReq.Password)
}

// .vs.KVInfo Kvs = 5;
inline bool DbPingReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool DbPingReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void DbPingReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& DbPingReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& DbPingReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.DbPingReq.Kvs)
  return _internal_kvs();
}
inline void DbPingReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.DbPingReq.Kvs)
}
inline ::vs::KVInfo* DbPingReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* DbPingReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.DbPingReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* DbPingReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* DbPingReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.DbPingReq.Kvs)
  return _msg;
}
inline void DbPingReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.DbPingReq.Kvs)
}

// -------------------------------------------------------------------

// DbPingResp

// int32 Flag = 1;
inline void DbPingResp::clear_flag() {
  flag_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DbPingResp::_internal_flag() const {
  return flag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DbPingResp::flag() const {
  // @@protoc_insertion_point(field_get:vs.DbPingResp.Flag)
  return _internal_flag();
}
inline void DbPingResp::_internal_set_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  flag_ = value;
}
inline void DbPingResp::set_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:vs.DbPingResp.Flag)
}

// -------------------------------------------------------------------

// ErrInfo

// int32 ErrCode = 1;
inline void ErrInfo::clear_errcode() {
  errcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ErrInfo::_internal_errcode() const {
  return errcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ErrInfo::errcode() const {
  // @@protoc_insertion_point(field_get:vs.ErrInfo.ErrCode)
  return _internal_errcode();
}
inline void ErrInfo::_internal_set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  errcode_ = value;
}
inline void ErrInfo::set_errcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:vs.ErrInfo.ErrCode)
}

// string ErrMsg = 2;
inline void ErrInfo::clear_errmsg() {
  errmsg_.ClearToEmpty();
}
inline const std::string& ErrInfo::errmsg() const {
  // @@protoc_insertion_point(field_get:vs.ErrInfo.ErrMsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrInfo::set_errmsg(ArgT0&& arg0, ArgT... args) {
 
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.ErrInfo.ErrMsg)
}
inline std::string* ErrInfo::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:vs.ErrInfo.ErrMsg)
  return _s;
}
inline const std::string& ErrInfo::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void ErrInfo::_internal_set_errmsg(const std::string& value) {
  
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ErrInfo::_internal_mutable_errmsg() {
  
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ErrInfo::release_errmsg() {
  // @@protoc_insertion_point(field_release:vs.ErrInfo.ErrMsg)
  return errmsg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ErrInfo::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    
  } else {
    
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.ErrInfo.ErrMsg)
}

// -------------------------------------------------------------------

// VsValue

// double Value = 1;
inline void VsValue::clear_value() {
  value_ = 0;
}
inline double VsValue::_internal_value() const {
  return value_;
}
inline double VsValue::value() const {
  // @@protoc_insertion_point(field_get:vs.VsValue.Value)
  return _internal_value();
}
inline void VsValue::_internal_set_value(double value) {
  
  value_ = value;
}
inline void VsValue::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:vs.VsValue.Value)
}

// int32 Time = 2;
inline void VsValue::clear_time() {
  time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::time() const {
  // @@protoc_insertion_point(field_get:vs.VsValue.Time)
  return _internal_time();
}
inline void VsValue::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  time_ = value;
}
inline void VsValue::set_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:vs.VsValue.Time)
}

// int32 Status = 3;
inline void VsValue::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VsValue::status() const {
  // @@protoc_insertion_point(field_get:vs.VsValue.Status)
  return _internal_status();
}
inline void VsValue::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void VsValue::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:vs.VsValue.Status)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagValuesByCountGetReq

// int32 Start = 1;
inline void TagValuesByCountGetReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Start)
  return _internal_start();
}
inline void TagValuesByCountGetReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagValuesByCountGetReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.Start)
}

// int32 End = 2;
inline void TagValuesByCountGetReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.End)
  return _internal_end();
}
inline void TagValuesByCountGetReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagValuesByCountGetReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.End)
}

// string TagName = 3;
inline void TagValuesByCountGetReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagValuesByCountGetReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesByCountGetReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.TagName)
}
inline std::string* TagValuesByCountGetReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetReq.TagName)
  return _s;
}
inline const std::string& TagValuesByCountGetReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagValuesByCountGetReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesByCountGetReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetReq.TagName)
}

// int32 TagId = 4;
inline void TagValuesByCountGetReq::clear_tagid() {
  tagid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::_internal_tagid() const {
  return tagid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::tagid() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.TagId)
  return _internal_tagid();
}
inline void TagValuesByCountGetReq::_internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tagid_ = value;
}
inline void TagValuesByCountGetReq::set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.TagId)
}

// string Addr = 5;
inline void TagValuesByCountGetReq::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& TagValuesByCountGetReq::addr() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesByCountGetReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.Addr)
}
inline std::string* TagValuesByCountGetReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetReq.Addr)
  return _s;
}
inline const std::string& TagValuesByCountGetReq::_internal_addr() const {
  return addr_.Get();
}
inline void TagValuesByCountGetReq::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::release_addr() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetReq.Addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesByCountGetReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetReq.Addr)
}

// string Username = 6;
inline void TagValuesByCountGetReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& TagValuesByCountGetReq::username() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesByCountGetReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.Username)
}
inline std::string* TagValuesByCountGetReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetReq.Username)
  return _s;
}
inline const std::string& TagValuesByCountGetReq::_internal_username() const {
  return username_.Get();
}
inline void TagValuesByCountGetReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::release_username() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetReq.Username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesByCountGetReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetReq.Username)
}

// string Password = 7;
inline void TagValuesByCountGetReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& TagValuesByCountGetReq::password() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesByCountGetReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.Password)
}
inline std::string* TagValuesByCountGetReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetReq.Password)
  return _s;
}
inline const std::string& TagValuesByCountGetReq::_internal_password() const {
  return password_.Get();
}
inline void TagValuesByCountGetReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetReq::release_password() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetReq.Password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesByCountGetReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetReq.Password)
}

// int32 Count = 8;
inline void TagValuesByCountGetReq::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetReq::count() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Count)
  return _internal_count();
}
inline void TagValuesByCountGetReq::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagValuesByCountGetReq::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetReq.Count)
}

// .vs.KVInfo Kvs = 9;
inline bool TagValuesByCountGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagValuesByCountGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagValuesByCountGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagValuesByCountGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagValuesByCountGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetReq.Kvs)
  return _internal_kvs();
}
inline void TagValuesByCountGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesByCountGetReq.Kvs)
}
inline ::vs::KVInfo* TagValuesByCountGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagValuesByCountGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagValuesByCountGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagValuesByCountGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetReq.Kvs)
  return _msg;
}
inline void TagValuesByCountGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetReq.Kvs)
}

// map<string, string> Meta = 10;
inline int TagValuesByCountGetReq::_internal_meta_size() const {
  return meta_.size();
}
inline int TagValuesByCountGetReq::meta_size() const {
  return _internal_meta_size();
}
inline void TagValuesByCountGetReq::clear_meta() {
  meta_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesByCountGetReq::_internal_meta() const {
  return meta_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesByCountGetReq::meta() const {
  // @@protoc_insertion_point(field_map:vs.TagValuesByCountGetReq.Meta)
  return _internal_meta();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesByCountGetReq::_internal_mutable_meta() {
  return meta_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesByCountGetReq::mutable_meta() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagValuesByCountGetReq.Meta)
  return _internal_mutable_meta();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagValuesByCountGetResp_VsValue

// map<string, string> ValueMap = 1;
inline int TagValuesByCountGetResp_VsValue::_internal_valuemap_size() const {
  return valuemap_.size();
}
inline int TagValuesByCountGetResp_VsValue::valuemap_size() const {
  return _internal_valuemap_size();
}
inline void TagValuesByCountGetResp_VsValue::clear_valuemap() {
  valuemap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesByCountGetResp_VsValue::_internal_valuemap() const {
  return valuemap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesByCountGetResp_VsValue::valuemap() const {
  // @@protoc_insertion_point(field_map:vs.TagValuesByCountGetResp.VsValue.ValueMap)
  return _internal_valuemap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesByCountGetResp_VsValue::_internal_mutable_valuemap() {
  return valuemap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesByCountGetResp_VsValue::mutable_valuemap() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagValuesByCountGetResp.VsValue.ValueMap)
  return _internal_mutable_valuemap();
}

// -------------------------------------------------------------------

// TagValuesByCountGetResp

// .vs.ErrInfo Err = 1;
inline bool TagValuesByCountGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagValuesByCountGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagValuesByCountGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagValuesByCountGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagValuesByCountGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.Err)
  return _internal_err();
}
inline void TagValuesByCountGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesByCountGetResp.Err)
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagValuesByCountGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetResp.Err)
  return _msg;
}
inline void TagValuesByCountGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetResp.Err)
}

// repeated .vs.TagValuesByCountGetResp.VsValue Values = 2;
inline int TagValuesByCountGetResp::_internal_values_size() const {
  return values_.size();
}
inline int TagValuesByCountGetResp::values_size() const {
  return _internal_values_size();
}
inline void TagValuesByCountGetResp::clear_values() {
  values_.Clear();
}
inline ::vs::TagValuesByCountGetResp_VsValue* TagValuesByCountGetResp::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetResp.Values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesByCountGetResp_VsValue >*
TagValuesByCountGetResp::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagValuesByCountGetResp.Values)
  return &values_;
}
inline const ::vs::TagValuesByCountGetResp_VsValue& TagValuesByCountGetResp::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::vs::TagValuesByCountGetResp_VsValue& TagValuesByCountGetResp::values(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.Values)
  return _internal_values(index);
}
inline ::vs::TagValuesByCountGetResp_VsValue* TagValuesByCountGetResp::_internal_add_values() {
  return values_.Add();
}
inline ::vs::TagValuesByCountGetResp_VsValue* TagValuesByCountGetResp::add_values() {
  ::vs::TagValuesByCountGetResp_VsValue* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:vs.TagValuesByCountGetResp.Values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesByCountGetResp_VsValue >&
TagValuesByCountGetResp::values() const {
  // @@protoc_insertion_point(field_list:vs.TagValuesByCountGetResp.Values)
  return values_;
}

// string ValueType = 3;
inline void TagValuesByCountGetResp::clear_valuetype() {
  valuetype_.ClearToEmpty();
}
inline const std::string& TagValuesByCountGetResp::valuetype() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.ValueType)
  return _internal_valuetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesByCountGetResp::set_valuetype(ArgT0&& arg0, ArgT... args) {
 
 valuetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.ValueType)
}
inline std::string* TagValuesByCountGetResp::mutable_valuetype() {
  std::string* _s = _internal_mutable_valuetype();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesByCountGetResp.ValueType)
  return _s;
}
inline const std::string& TagValuesByCountGetResp::_internal_valuetype() const {
  return valuetype_.Get();
}
inline void TagValuesByCountGetResp::_internal_set_valuetype(const std::string& value) {
  
  valuetype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetResp::_internal_mutable_valuetype() {
  
  return valuetype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesByCountGetResp::release_valuetype() {
  // @@protoc_insertion_point(field_release:vs.TagValuesByCountGetResp.ValueType)
  return valuetype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesByCountGetResp::set_allocated_valuetype(std::string* valuetype) {
  if (valuetype != nullptr) {
    
  } else {
    
  }
  valuetype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), valuetype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesByCountGetResp.ValueType)
}

// int32 Start = 4;
inline void TagValuesByCountGetResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.Start)
  return _internal_start();
}
inline void TagValuesByCountGetResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagValuesByCountGetResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.Start)
}

// int32 End = 5;
inline void TagValuesByCountGetResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesByCountGetResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.End)
  return _internal_end();
}
inline void TagValuesByCountGetResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagValuesByCountGetResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.End)
}

// bool IsLast = 6;
inline void TagValuesByCountGetResp::clear_islast() {
  islast_ = false;
}
inline bool TagValuesByCountGetResp::_internal_islast() const {
  return islast_;
}
inline bool TagValuesByCountGetResp::islast() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesByCountGetResp.IsLast)
  return _internal_islast();
}
inline void TagValuesByCountGetResp::_internal_set_islast(bool value) {
  
  islast_ = value;
}
inline void TagValuesByCountGetResp::set_islast(bool value) {
  _internal_set_islast(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesByCountGetResp.IsLast)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagValuesGetReq

// int32 Start = 1;
inline void TagValuesGetReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Start)
  return _internal_start();
}
inline void TagValuesGetReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagValuesGetReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.Start)
}

// int32 End = 2;
inline void TagValuesGetReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.End)
  return _internal_end();
}
inline void TagValuesGetReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagValuesGetReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.End)
}

// string TagName = 3;
inline void TagValuesGetReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagValuesGetReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesGetReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.TagName)
}
inline std::string* TagValuesGetReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetReq.TagName)
  return _s;
}
inline const std::string& TagValuesGetReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagValuesGetReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesGetReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetReq.TagName)
}

// int32 TagId = 4;
inline void TagValuesGetReq::clear_tagid() {
  tagid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::_internal_tagid() const {
  return tagid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::tagid() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.TagId)
  return _internal_tagid();
}
inline void TagValuesGetReq::_internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tagid_ = value;
}
inline void TagValuesGetReq::set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.TagId)
}

// string Addr = 5;
inline void TagValuesGetReq::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& TagValuesGetReq::addr() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesGetReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.Addr)
}
inline std::string* TagValuesGetReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetReq.Addr)
  return _s;
}
inline const std::string& TagValuesGetReq::_internal_addr() const {
  return addr_.Get();
}
inline void TagValuesGetReq::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::release_addr() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetReq.Addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesGetReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetReq.Addr)
}

// string Username = 6;
inline void TagValuesGetReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& TagValuesGetReq::username() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesGetReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.Username)
}
inline std::string* TagValuesGetReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetReq.Username)
  return _s;
}
inline const std::string& TagValuesGetReq::_internal_username() const {
  return username_.Get();
}
inline void TagValuesGetReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::release_username() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetReq.Username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesGetReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetReq.Username)
}

// string Password = 7;
inline void TagValuesGetReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& TagValuesGetReq::password() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagValuesGetReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.Password)
}
inline std::string* TagValuesGetReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetReq.Password)
  return _s;
}
inline const std::string& TagValuesGetReq::_internal_password() const {
  return password_.Get();
}
inline void TagValuesGetReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagValuesGetReq::release_password() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetReq.Password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagValuesGetReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetReq.Password)
}

// int32 Count = 8;
inline void TagValuesGetReq::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetReq::count() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Count)
  return _internal_count();
}
inline void TagValuesGetReq::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagValuesGetReq::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetReq.Count)
}

// .vs.KVInfo Kvs = 9;
inline bool TagValuesGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagValuesGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagValuesGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagValuesGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagValuesGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetReq.Kvs)
  return _internal_kvs();
}
inline void TagValuesGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesGetReq.Kvs)
}
inline ::vs::KVInfo* TagValuesGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagValuesGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagValuesGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagValuesGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetReq.Kvs)
  return _msg;
}
inline void TagValuesGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetReq.Kvs)
}

// map<string, string> Extend = 10;
inline int TagValuesGetReq::_internal_extend_size() const {
  return extend_.size();
}
inline int TagValuesGetReq::extend_size() const {
  return _internal_extend_size();
}
inline void TagValuesGetReq::clear_extend() {
  extend_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesGetReq::_internal_extend() const {
  return extend_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesGetReq::extend() const {
  // @@protoc_insertion_point(field_map:vs.TagValuesGetReq.Extend)
  return _internal_extend();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesGetReq::_internal_mutable_extend() {
  return extend_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesGetReq::mutable_extend() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagValuesGetReq.Extend)
  return _internal_mutable_extend();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagValuesGetResp_VsValue

// map<string, string> ValueMap = 1;
inline int TagValuesGetResp_VsValue::_internal_valuemap_size() const {
  return valuemap_.size();
}
inline int TagValuesGetResp_VsValue::valuemap_size() const {
  return _internal_valuemap_size();
}
inline void TagValuesGetResp_VsValue::clear_valuemap() {
  valuemap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesGetResp_VsValue::_internal_valuemap() const {
  return valuemap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagValuesGetResp_VsValue::valuemap() const {
  // @@protoc_insertion_point(field_map:vs.TagValuesGetResp.VsValue.ValueMap)
  return _internal_valuemap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesGetResp_VsValue::_internal_mutable_valuemap() {
  return valuemap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagValuesGetResp_VsValue::mutable_valuemap() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagValuesGetResp.VsValue.ValueMap)
  return _internal_mutable_valuemap();
}

// -------------------------------------------------------------------

// TagValuesGetResp

// .vs.ErrInfo Err = 1;
inline bool TagValuesGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagValuesGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagValuesGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagValuesGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagValuesGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.Err)
  return _internal_err();
}
inline void TagValuesGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagValuesGetResp.Err)
}
inline ::vs::ErrInfo* TagValuesGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagValuesGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagValuesGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagValuesGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagValuesGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetResp.Err)
  return _msg;
}
inline void TagValuesGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagValuesGetResp.Err)
}

// repeated .vs.TagValuesGetResp.VsValue Values = 2;
inline int TagValuesGetResp::_internal_values_size() const {
  return values_.size();
}
inline int TagValuesGetResp::values_size() const {
  return _internal_values_size();
}
inline void TagValuesGetResp::clear_values() {
  values_.Clear();
}
inline ::vs::TagValuesGetResp_VsValue* TagValuesGetResp::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:vs.TagValuesGetResp.Values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesGetResp_VsValue >*
TagValuesGetResp::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagValuesGetResp.Values)
  return &values_;
}
inline const ::vs::TagValuesGetResp_VsValue& TagValuesGetResp::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::vs::TagValuesGetResp_VsValue& TagValuesGetResp::values(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.Values)
  return _internal_values(index);
}
inline ::vs::TagValuesGetResp_VsValue* TagValuesGetResp::_internal_add_values() {
  return values_.Add();
}
inline ::vs::TagValuesGetResp_VsValue* TagValuesGetResp::add_values() {
  ::vs::TagValuesGetResp_VsValue* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:vs.TagValuesGetResp.Values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vs::TagValuesGetResp_VsValue >&
TagValuesGetResp::values() const {
  // @@protoc_insertion_point(field_list:vs.TagValuesGetResp.Values)
  return values_;
}

// int32 Start = 3;
inline void TagValuesGetResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.Start)
  return _internal_start();
}
inline void TagValuesGetResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagValuesGetResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetResp.Start)
}

// int32 End = 4;
inline void TagValuesGetResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagValuesGetResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagValuesGetResp.End)
  return _internal_end();
}
inline void TagValuesGetResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagValuesGetResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagValuesGetResp.End)
}

// -------------------------------------------------------------------

// TagFeatureGetReq

// int64 Start = 1;
inline void TagFeatureGetReq::clear_start() {
  start_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Start)
  return _internal_start();
}
inline void TagFeatureGetReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_ = value;
}
inline void TagFeatureGetReq::set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Start)
}

// int64 End = 2;
inline void TagFeatureGetReq::clear_end() {
  end_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TagFeatureGetReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.End)
  return _internal_end();
}
inline void TagFeatureGetReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_ = value;
}
inline void TagFeatureGetReq::set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.End)
}

// string TagName = 3;
inline void TagFeatureGetReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagFeatureGetReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagFeatureGetReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.TagName)
}
inline std::string* TagFeatureGetReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetReq.TagName)
  return _s;
}
inline const std::string& TagFeatureGetReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagFeatureGetReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagFeatureGetReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetReq.TagName)
}

// int32 TagId = 4;
inline void TagFeatureGetReq::clear_tagid() {
  tagid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::_internal_tagid() const {
  return tagid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::tagid() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.TagId)
  return _internal_tagid();
}
inline void TagFeatureGetReq::_internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tagid_ = value;
}
inline void TagFeatureGetReq::set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.TagId)
}

// repeated int32 Verifies = 5;
inline int TagFeatureGetReq::_internal_verifies_size() const {
  return verifies_.size();
}
inline int TagFeatureGetReq::verifies_size() const {
  return _internal_verifies_size();
}
inline void TagFeatureGetReq::clear_verifies() {
  verifies_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::_internal_verifies(int index) const {
  return verifies_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::verifies(int index) const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Verifies)
  return _internal_verifies(index);
}
inline void TagFeatureGetReq::set_verifies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  verifies_.Set(index, value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Verifies)
}
inline void TagFeatureGetReq::_internal_add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  verifies_.Add(value);
}
inline void TagFeatureGetReq::add_verifies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_verifies(value);
  // @@protoc_insertion_point(field_add:vs.TagFeatureGetReq.Verifies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TagFeatureGetReq::_internal_verifies() const {
  return verifies_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TagFeatureGetReq::verifies() const {
  // @@protoc_insertion_point(field_list:vs.TagFeatureGetReq.Verifies)
  return _internal_verifies();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TagFeatureGetReq::_internal_mutable_verifies() {
  return &verifies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TagFeatureGetReq::mutable_verifies() {
  // @@protoc_insertion_point(field_mutable_list:vs.TagFeatureGetReq.Verifies)
  return _internal_mutable_verifies();
}

// int32 Count = 6;
inline void TagFeatureGetReq::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetReq::count() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Count)
  return _internal_count();
}
inline void TagFeatureGetReq::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
}
inline void TagFeatureGetReq::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Count)
}

// string Addr = 7;
inline void TagFeatureGetReq::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& TagFeatureGetReq::addr() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagFeatureGetReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Addr)
}
inline std::string* TagFeatureGetReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetReq.Addr)
  return _s;
}
inline const std::string& TagFeatureGetReq::_internal_addr() const {
  return addr_.Get();
}
inline void TagFeatureGetReq::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::release_addr() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetReq.Addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagFeatureGetReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetReq.Addr)
}

// string Username = 8;
inline void TagFeatureGetReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& TagFeatureGetReq::username() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagFeatureGetReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Username)
}
inline std::string* TagFeatureGetReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetReq.Username)
  return _s;
}
inline const std::string& TagFeatureGetReq::_internal_username() const {
  return username_.Get();
}
inline void TagFeatureGetReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::release_username() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetReq.Username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagFeatureGetReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetReq.Username)
}

// string Password = 9;
inline void TagFeatureGetReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& TagFeatureGetReq::password() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagFeatureGetReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetReq.Password)
}
inline std::string* TagFeatureGetReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetReq.Password)
  return _s;
}
inline const std::string& TagFeatureGetReq::_internal_password() const {
  return password_.Get();
}
inline void TagFeatureGetReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagFeatureGetReq::release_password() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetReq.Password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagFeatureGetReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetReq.Password)
}

// .vs.KVInfo Kvs = 10;
inline bool TagFeatureGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagFeatureGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagFeatureGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagFeatureGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagFeatureGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetReq.Kvs)
  return _internal_kvs();
}
inline void TagFeatureGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagFeatureGetReq.Kvs)
}
inline ::vs::KVInfo* TagFeatureGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagFeatureGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagFeatureGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagFeatureGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetReq.Kvs)
  return _msg;
}
inline void TagFeatureGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetReq.Kvs)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagFeatureGetResp

// .vs.ErrInfo Err = 1;
inline bool TagFeatureGetResp::_internal_has_err() const {
  return this != internal_default_instance() && err_ != nullptr;
}
inline bool TagFeatureGetResp::has_err() const {
  return _internal_has_err();
}
inline void TagFeatureGetResp::clear_err() {
  if (GetArenaForAllocation() == nullptr && err_ != nullptr) {
    delete err_;
  }
  err_ = nullptr;
}
inline const ::vs::ErrInfo& TagFeatureGetResp::_internal_err() const {
  const ::vs::ErrInfo* p = err_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::ErrInfo&>(
      ::vs::_ErrInfo_default_instance_);
}
inline const ::vs::ErrInfo& TagFeatureGetResp::err() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetResp.Err)
  return _internal_err();
}
inline void TagFeatureGetResp::unsafe_arena_set_allocated_err(
    ::vs::ErrInfo* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err_);
  }
  err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagFeatureGetResp.Err)
}
inline ::vs::ErrInfo* TagFeatureGetResp::release_err() {
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::ErrInfo* TagFeatureGetResp::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:vs.TagFeatureGetResp.Err)
  
  ::vs::ErrInfo* temp = err_;
  err_ = nullptr;
  return temp;
}
inline ::vs::ErrInfo* TagFeatureGetResp::_internal_mutable_err() {
  
  if (err_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::ErrInfo>(GetArenaForAllocation());
    err_ = p;
  }
  return err_;
}
inline ::vs::ErrInfo* TagFeatureGetResp::mutable_err() {
  ::vs::ErrInfo* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:vs.TagFeatureGetResp.Err)
  return _msg;
}
inline void TagFeatureGetResp::set_allocated_err(::vs::ErrInfo* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete err_;
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::ErrInfo>::GetOwningArena(err);
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:vs.TagFeatureGetResp.Err)
}

// map<string, .vs.VsValue> Feat = 2;
inline int TagFeatureGetResp::_internal_feat_size() const {
  return feat_.size();
}
inline int TagFeatureGetResp::feat_size() const {
  return _internal_feat_size();
}
inline void TagFeatureGetResp::clear_feat() {
  feat_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
TagFeatureGetResp::_internal_feat() const {
  return feat_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >&
TagFeatureGetResp::feat() const {
  // @@protoc_insertion_point(field_map:vs.TagFeatureGetResp.Feat)
  return _internal_feat();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
TagFeatureGetResp::_internal_mutable_feat() {
  return feat_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vs::VsValue >*
TagFeatureGetResp::mutable_feat() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagFeatureGetResp.Feat)
  return _internal_mutable_feat();
}

// int32 Start = 3;
inline void TagFeatureGetResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetResp.Start)
  return _internal_start();
}
inline void TagFeatureGetResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagFeatureGetResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetResp.Start)
}

// int32 End = 4;
inline void TagFeatureGetResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagFeatureGetResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagFeatureGetResp.End)
  return _internal_end();
}
inline void TagFeatureGetResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagFeatureGetResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagFeatureGetResp.End)
}

// -------------------------------------------------------------------

// TagDescGetReq

// .vs.KVInfo Kvs = 1;
inline bool TagDescGetReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagDescGetReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagDescGetReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagDescGetReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagDescGetReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagDescGetReq.Kvs)
  return _internal_kvs();
}
inline void TagDescGetReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagDescGetReq.Kvs)
}
inline ::vs::KVInfo* TagDescGetReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagDescGetReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagDescGetReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagDescGetReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagDescGetReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagDescGetReq.Kvs)
  return _msg;
}
inline void TagDescGetReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagDescGetReq.Kvs)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TagDescGetResp

// string Name = 1;
inline void TagDescGetResp::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TagDescGetResp::name() const {
  // @@protoc_insertion_point(field_get:vs.TagDescGetResp.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDescGetResp::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagDescGetResp.Name)
}
inline std::string* TagDescGetResp::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vs.TagDescGetResp.Name)
  return _s;
}
inline const std::string& TagDescGetResp::_internal_name() const {
  return name_.Get();
}
inline void TagDescGetResp::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagDescGetResp::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagDescGetResp::release_name() {
  // @@protoc_insertion_point(field_release:vs.TagDescGetResp.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagDescGetResp::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagDescGetResp.Name)
}

// map<string, string> Desc = 2;
inline int TagDescGetResp::_internal_desc_size() const {
  return desc_.size();
}
inline int TagDescGetResp::desc_size() const {
  return _internal_desc_size();
}
inline void TagDescGetResp::clear_desc() {
  desc_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagDescGetResp::_internal_desc() const {
  return desc_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TagDescGetResp::desc() const {
  // @@protoc_insertion_point(field_map:vs.TagDescGetResp.Desc)
  return _internal_desc();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagDescGetResp::_internal_mutable_desc() {
  return desc_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TagDescGetResp::mutable_desc() {
  // @@protoc_insertion_point(field_mutable_map:vs.TagDescGetResp.Desc)
  return _internal_mutable_desc();
}

// -------------------------------------------------------------------

// TagTimeSectionReq

// string TagName = 1;
inline void TagTimeSectionReq::clear_tagname() {
  tagname_.ClearToEmpty();
}
inline const std::string& TagTimeSectionReq::tagname() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.TagName)
  return _internal_tagname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagTimeSectionReq::set_tagname(ArgT0&& arg0, ArgT... args) {
 
 tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.TagName)
}
inline std::string* TagTimeSectionReq::mutable_tagname() {
  std::string* _s = _internal_mutable_tagname();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionReq.TagName)
  return _s;
}
inline const std::string& TagTimeSectionReq::_internal_tagname() const {
  return tagname_.Get();
}
inline void TagTimeSectionReq::_internal_set_tagname(const std::string& value) {
  
  tagname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::_internal_mutable_tagname() {
  
  return tagname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::release_tagname() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionReq.TagName)
  return tagname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagTimeSectionReq::set_allocated_tagname(std::string* tagname) {
  if (tagname != nullptr) {
    
  } else {
    
  }
  tagname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tagname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionReq.TagName)
}

// int32 TagId = 2;
inline void TagTimeSectionReq::clear_tagid() {
  tagid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::_internal_tagid() const {
  return tagid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::tagid() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.TagId)
  return _internal_tagid();
}
inline void TagTimeSectionReq::_internal_set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tagid_ = value;
}
inline void TagTimeSectionReq::set_tagid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.TagId)
}

// string Addr = 3;
inline void TagTimeSectionReq::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& TagTimeSectionReq::addr() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.Addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagTimeSectionReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.Addr)
}
inline std::string* TagTimeSectionReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionReq.Addr)
  return _s;
}
inline const std::string& TagTimeSectionReq::_internal_addr() const {
  return addr_.Get();
}
inline void TagTimeSectionReq::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::release_addr() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionReq.Addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagTimeSectionReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionReq.Addr)
}

// string Username = 4;
inline void TagTimeSectionReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& TagTimeSectionReq::username() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.Username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagTimeSectionReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.Username)
}
inline std::string* TagTimeSectionReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionReq.Username)
  return _s;
}
inline const std::string& TagTimeSectionReq::_internal_username() const {
  return username_.Get();
}
inline void TagTimeSectionReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::release_username() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionReq.Username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagTimeSectionReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionReq.Username)
}

// string Password = 5;
inline void TagTimeSectionReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& TagTimeSectionReq::password() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagTimeSectionReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.Password)
}
inline std::string* TagTimeSectionReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionReq.Password)
  return _s;
}
inline const std::string& TagTimeSectionReq::_internal_password() const {
  return password_.Get();
}
inline void TagTimeSectionReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TagTimeSectionReq::release_password() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionReq.Password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TagTimeSectionReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionReq.Password)
}

// int32 Start = 6;
inline void TagTimeSectionReq::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::start() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.Start)
  return _internal_start();
}
inline void TagTimeSectionReq::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagTimeSectionReq::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.Start)
}

// int32 End = 7;
inline void TagTimeSectionReq::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionReq::end() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.End)
  return _internal_end();
}
inline void TagTimeSectionReq::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagTimeSectionReq::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionReq.End)
}

// .vs.KVInfo Kvs = 8;
inline bool TagTimeSectionReq::_internal_has_kvs() const {
  return this != internal_default_instance() && kvs_ != nullptr;
}
inline bool TagTimeSectionReq::has_kvs() const {
  return _internal_has_kvs();
}
inline void TagTimeSectionReq::clear_kvs() {
  if (GetArenaForAllocation() == nullptr && kvs_ != nullptr) {
    delete kvs_;
  }
  kvs_ = nullptr;
}
inline const ::vs::KVInfo& TagTimeSectionReq::_internal_kvs() const {
  const ::vs::KVInfo* p = kvs_;
  return p != nullptr ? *p : reinterpret_cast<const ::vs::KVInfo&>(
      ::vs::_KVInfo_default_instance_);
}
inline const ::vs::KVInfo& TagTimeSectionReq::kvs() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionReq.Kvs)
  return _internal_kvs();
}
inline void TagTimeSectionReq::unsafe_arena_set_allocated_kvs(
    ::vs::KVInfo* kvs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kvs_);
  }
  kvs_ = kvs;
  if (kvs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vs.TagTimeSectionReq.Kvs)
}
inline ::vs::KVInfo* TagTimeSectionReq::release_kvs() {
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vs::KVInfo* TagTimeSectionReq::unsafe_arena_release_kvs() {
  // @@protoc_insertion_point(field_release:vs.TagTimeSectionReq.Kvs)
  
  ::vs::KVInfo* temp = kvs_;
  kvs_ = nullptr;
  return temp;
}
inline ::vs::KVInfo* TagTimeSectionReq::_internal_mutable_kvs() {
  
  if (kvs_ == nullptr) {
    auto* p = CreateMaybeMessage<::vs::KVInfo>(GetArenaForAllocation());
    kvs_ = p;
  }
  return kvs_;
}
inline ::vs::KVInfo* TagTimeSectionReq::mutable_kvs() {
  ::vs::KVInfo* _msg = _internal_mutable_kvs();
  // @@protoc_insertion_point(field_mutable:vs.TagTimeSectionReq.Kvs)
  return _msg;
}
inline void TagTimeSectionReq::set_allocated_kvs(::vs::KVInfo* kvs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kvs_;
  }
  if (kvs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::vs::KVInfo>::GetOwningArena(kvs);
    if (message_arena != submessage_arena) {
      kvs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kvs, submessage_arena);
    }
    
  } else {
    
  }
  kvs_ = kvs;
  // @@protoc_insertion_point(field_set_allocated:vs.TagTimeSectionReq.Kvs)
}

// -------------------------------------------------------------------

// TagTimeSectionResp

// int32 Start = 1;
inline void TagTimeSectionResp::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::start() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionResp.Start)
  return _internal_start();
}
inline void TagTimeSectionResp::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
}
inline void TagTimeSectionResp::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionResp.Start)
}

// int32 End = 2;
inline void TagTimeSectionResp::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TagTimeSectionResp::end() const {
  // @@protoc_insertion_point(field_get:vs.TagTimeSectionResp.End)
  return _internal_end();
}
inline void TagTimeSectionResp::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
}
inline void TagTimeSectionResp::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:vs.TagTimeSectionResp.End)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vs

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vs_2eproto
